---
layout: tutpage
axis: doc-hoon
categories: tut
sort: 4
title: IV - Gates
---

> Anyone who thinks he's original is merely ignorant.
> - Nicolás Gómez Dávila

So.  We managed to implement a decrement algorithm in Hoon in the last chapter.  
But we didn't actually produce a decrement *function*.  
Let's do that now.

##Gates and "lambda"##

In your Earth programming life, you learned about functions, among other
things.  A closely related thing in Hoon is the `gate`.  

A `gate` is a kind of `core` - you might remember from earlier discussions, a `core` is

    [battery payload]

The `battery` is one or more formulas; the `payload` is any noun.

To expand on this a bit: a `battery` is always a cell, which may 
be a single formula, or a tree of formulas.  These formulas are 
called `arms`.  Arms have names.

The `payload` is any noun -- meaning it could in general be an atom.
In the case of a `gate`, however, the `payload` is always a cell, whose 
head and tail are called `sample` and `context`.  

    [battery [sample context]]

In a `gate`, the `battery` is exactly one `arm` - one formula,  whose name is `$`, `buc` or
`blip` - ie, nothing.

Remember again, a name is a symbol which is bound to an axis, and an axis
is a location in a particular noun -- in this case the axis that contains 
our single formula.

One `arm`, one `twig`, one `formula` -- and a `payload` cell consisting of `sample` 
and `context`.

The hoon concept of `sample` and the Earth concept 'argument' are 
related in a similar way that `gate` and 'function' are.

And, the `context` is the environment that gives the gate its lambda-nature.

So - to combine several ways of deconstructing a noun - a gate looks like this:

               glus   gras
              lusgal lusgar
                +<     +>
    [formula [sample context]]
        -          +
       hep        lus

Another way: the `hep` of a `core`/`gate` is the formula; the `lus` is the payload.
`lusgal` (or `glus`) of a `gate` is the `sample` or what passes for the argument, and 
the `lusgar` (or `gras`) is the `context`.

In classical FP, something quite like a Hoon gate is known as a
"lambda." 

But here is a big difference: in classical FP, "lambda" is a
fundamental semantic primitive.  It is provided by the language 
as an *atomic component*.

But gates - Hoon's equivalent of lambdas - are no more than a design pattern: a convention.
They can be combined to produce things that are at the same level of abstraction as function 
calls, but ... different.

###We make a gate###

Our goal this time is to build decrement as a function - a gate.
An Earth language function is, essentially, a piece of re-useable 
code, code which takes certain inputs and produces certain outputs.

A `gate` is a rough equivalent -- it's more like a lambda, because 
it carries an environment with it, but it provides the same kind of 
feature -- a body of code, parameterized with inputs and providing a 
resulting value.

The `gate` does not seem not *quite* equivalent, though, since it doesn't have a name.
How do we re-use it?

Names are, ultimately, ways of referring to a place or a thing.

Any particular `gate` in a Hoon program must be in a particular place, and all places 
(axes) have default names -- the path from the top of the tree to the thing you want, 
which can be represented in a number of different ways.  So any particular gate 
always has a name, effectively.

But for humans, this does not work so well.  So Hoon provides a way of naming places, 
and for arms of gates, this is done with the `++` (spoken, "luslus") syntax.

We will call our function `deq` (there already being a perfectly usable 
`dec`), and we will write the code which invokes that function as

    (deq a)

To focus on Hoon itself, we will write the code in the following form:

    !:             ::  To write a trivial Hoon program
    |=  *          ::
    |=  [a=@ ~]    ::  For educational purposes only
    :_  ~  :_  ~   ::
    :-  %$         ::  Preserve this mysterious boilerplate square
    !>             ::
    :::::::::::::::::  Produce a value below
    =>  XXXXX      ::  some twig or other
    (deq a)

As the comments say, pay no attention for now to the 'boilerplate'.
But a fifty-thousand foot view for the curious: it allows our snippet
of code to be run from the Arvo command line.

This `XXXXX` twig, whatever it is, must ... allow the form `(deq a)` 
to do what we want... which is to call the function `deq`, right?

Hold that thought.

Remembering `=>`, we are *extending the subject to contain* something ... 

Well... we can't just produce the gate -- we need to prevent it 
from being executed until it is applied to the sample we want.  We want to 
hand it as a thing to the part of the system which needs to use it.  This is 
how we get re-use -- rather than writing the code in-place where it is to 
be 'run', we store it as an `arm` and can then refer to it 
later on -- that is, further down the tree of computation.

So, we need to make a `core` which includes an `arm` which defines, and when 
pulled, produces our `gate` -- the function we are defining gets a name.

Be patient.  These concepts are similar to, but different enough from, the 
concepts you learned as an Earth programmer, to require us to break them 
apart at this level.  Once you've been down the rabbit hole, it will all fit 
back together as coherent whole, just like the old Earth programming concepts 
do now.

Differently put, whatever our definition looks like, it will involve
a `core` with an `arm` which produces the `gate` to be applied to the 
argument `a`.  `[a ~]` is going to become the `payload` of that eventual `gate`.

Thus, the `sample` is `a` and the `context` is `~` -- nothing.

If you are inclined to peek behind the "boilerplate curtain" you may note 
a strong and suspicious resemblance between part of the third line and
the `sample`, `[a ~]`.

Hold that thought, too.

What do we name this `arm`?  Oh right, we're calling it `deq`.

So... extend the subject (`=>`) to contain a core (`|%`) which includes an 
arm (`++  deq ... --`) which produces our gate?  Sure:

```
=>  |%
    ++  deq
      =+  x=0
      |.  =+  y=0
          |-  ?:  =(x +(y))
                y
              $(y +(y))
    --
(deq a)
```
Or more conveniently:

```
=<  (deq a)
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
```

Which we might describe in English as 

"create and invoke the gate `deq` on sample `a` with the following subject..."

Does this work?

    : /~zod/try/25/bin/deq/hoon
    ~zod/try=> :deq 42
    41

But this doesn't mean we understand it.  

Sure, we read the last chapter.  So we understand how and why
`|%` turned into `|.`, which then turned into `|-`.  The loop.
But this strange beast seems to contain... *three* cores? 

###We understand a gate##

Actually, we have a lot more than three nested cores, because the subject we are getting
for the application contains all of `zuse.hoon` and `hoon.hoon`.  

Remember. we *extended* the subject with (`=>`, or `=<` in the final variant).

What was the *subject* before we extended it?

Well, it was ... just as it says above. Perhaps, think of it as a namespace you are
linking against.

In any case, the subject we are extending is a stack of cores.

A stack of cores in which the core below is the payload of the
one above, all the way down to the innermost core whose payload
is a simple constant (for `hoon.hoon`, always the Kelvin version)
is called, for obvious reasons, a `reef`.  With our three cores,
we are adding no more than a few decorative polyps to our reef.

For example, we can just as well use the standard decrement,
`dec` - it's in there too:

```
=<  (dec a)
|%
++  deq
  =+  x=0
  |.  
  =+  y=0
  |-  
  ?:  =(x +(y))
    y
  $(y +(y))
--
```

(We've used a more conservative indentation here - uglier and
less compact, but arguably clearer.)

We define `deq`, but we seem to be able to just call `dec`.  Why?
Because we read past cores which don't bind the arm we're looking
for; we can read all the way to the deepest layer in the Hoon 164
reef - which contains the official, original `dec`.

(It remains important not to profoundly abuse this magic power.
Every layer of core you add, of course, puts you farther from
some of the gates you want to use.  A smart interpreter can
smooth over this issue a little, but smart isn't free either.)

Thus, it should be perfectly clear what the three `bar` runes -
implying three cores - mean.  First, we have the `|%` which
contains `++deq`.  (When referring to an arm in informal text,
we use this syntax, though the actual language of course requires
a double space - when searching in a file, <code>++&ensp;&ensp;arm</code> will always
find the definition of `arm` and nothing else.)

This outer core defines *the library our decrement gate is in*.
Actually, "library" (or `book` - defined as a core which
contains only code and constant data) is not quite the right
terminology here.  Even though we don't use it and it shouldn't
in fact be there, the payload of this core contains dynamic
information such as `a`.

In actual fact our nascent integer math library  is really an
"object" or `cart` - ie, a core containing dynamic state.  This
is just wrong and we'll see later on how to do it right.

As in every core, the subject of every arm is the core itself.

The `|%` twig uses its own subject as part of the payload,
creating the familiar reef effect as the stack of cores piles up.

And this library is the `context` (or `+>`, `gras`) of the `payload`
of our `gate`.  Thus, the twig in the gate can use anything in the 
library - of course as needed.

The `sample` (or `+<`, `glus`) of the payload of our gate is 
simply any default noun for the type we want to compute on.  

Remember, of course, that the whole point of gates is that we 
change the sample, then compute the formula.  
Hoon is a typed language, so the sample can be safely replaced
by any noun in the same type.

Within `=+`, `tislus`, the old subject again becomes the context, and
the new subject adds the sample `^=(b 0)`.  This pair of sample
and context then becomes the payload within `|.`  Hence, we build
a gate.

And then, within this gate - the third core is the decrement loop
itself, as we built it in the last chapter.  *Note* that if
decrement did not need a counter variable or other incremental
state, we would need only two cores - we could recurse through
the decrement gate itself.  We'll see this in a little bit.

But again, put a different way, a core can allow us to create 
persistent state for later use.

Let's eschew synthetic runes and show the three cores as they
really are:

```
=<  (deq a)
|%
++  deq
  =+  x=0
  |%  
  ++  $
    =+  y=0
    =<  $
    |%  
    ++  $
      ?:  =(x +(y))
        y
      $(y +(y))
    --
  --
--
```

On the other hand, if we don't mind synthetics and lots of
parentheses, our decrement gate can also be a one-liner.  This is
perfectly legitimate Hoon style:

```
|%  ++  deq  =+(x=0 |.(=+(y=0 |-(?:(=(x +(y)) y $(y +(y)))))))
--
```

###We call a gate###

Note that we've still totally failed to explain `(deq a)`.  This
is obviously an irregular form.  Let's try to turn it back into
natural hoons, and figure out what it's doing.
 
We know that `deq` builds a gate.  We already know how to change
the sample, `+<` or `glus`, in that gate.  So let's drag it out 
and do it the ugly way:

```
=<  =+  foo=deq             ::  create the gate
    =+  bar=foo(+< a)       ::  replace its sample
    $.bar                   ::  invoke the gate
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
```

Does this work?  It's always nice to check...

    : /~zod/try/28/bin/hec/hoon
    ~zod/try=> :hec 42
    41

We don't actually need a separate `bar`:

```
=<  =+  foo=deq             ::  create the gate
    $.foo(+< a)             ::  replace the sample and invoke
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
```

But what we'd actually like to be able to get away with is...
something that *won't* work - but that looks like it might:

```
=<  $.deq(+< a)             ::  create, replace and invoke
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
```

We try it and - doh!

    : /~zod/try/31/bin/hec/hoon
    ~zod/try=> :hec 42
    ! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:<[2 1].[23 3]>
    ! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:<[3 1].[23 3]>
    ! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:<[4 1].[23 3]>
    ! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:<[4 8].[23 3]>
    ! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:<[5 1].[23 3]>
    ! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:<[6 1].[23 3]>
    ! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:<[8 1].[23 3]>
    ! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:<[8 5].[8 16]>
    ! type-fail
    ! exit

(This means we had a type failure between columns 5 and 16 of line
8, by the way.  More on troubleshooting errors later.)

What happened?  Well, `$.deq(+< a)` says, pull `deq` from `$`, then modify the `+<` of *that* result to be `a`. 
What is *that result*?  Well, if you think about it, it is the definition of the gate, and not the gate itself.
`=+ foo=dec(+< a)`  XXX this is still not clear to me.  What the hell is `$.`?  it's not documented in the runes page.


We need to modify the sample *before* we compute the result.
The way it's written, we try to replace the sample in the result 
of the computation -- which leads to the type error.

The change in `%=` - remember that `deq(+< a)` is a short form
for `%=(deq +< a)` - is always *before* the invocation.
So we can't do this as easily as it looks like we should be able
to do it - because we can't edit the gate until we build it.

Fortunately, we have a synthetic hoon to do this.  What hoon is
(deq a), anyway?  It's `%-`, `cenhep`, `%cnhp`:

```
=<  %-  deq
    a
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
```

Let's look at the definition of `%cnhp`, our function caller.
Here are the relevant clips from `hoon.hoon`:
 
    ++  twig
      |%  [%cnhp p=twig q=tusk]
      ==

    ++  tusk  (list twig)

    ++  open
      ^-  twig
      ?-    gen
          [%cnhp *]
        ?~(q.gen [%tsgr p.gen [%cnzy %$]] [%cncl p.gen [%cltr q.gen]])
      ::
          [%cncl *]  
        [%cnsg [%$ ~] p.gen q.gen]
      ::
          [%cnsg *]  
        [%cntr p.gen q.gen [[[[%& 6] ~] r.gen] ~]]
      ::
          [%cntr *]
        :+  %tsls
          q.gen
        :+  %cnts
          (weld p.gen `wing`[[~ 2] ~])
        (turn r.gen |=([p=wing q=twig] [p [%tsgr [~ 3] q]]))
      ==

You're not expected to understand this.  At least, not yet.  But
we see that `%-`, so far from being a primitive, actually is a
special case of `%:`, which is a special case of `%~`, which is a
special case of `%*`, which seems to do... something.

Which probably makes you think `%cnhp` is insanely complicated.
Actually it just shows what an interesting family of things
which are like function calls, but which are not function calls,
we have here in Hoon.  Defining `%cnhp` this way saves code, but
it doesn't help us understand the humble function call.

If we just wanted %cnhp to be simple, we'd define it this way:

    ++  twig
      |%  [%cnhp p=twig q=twig]
      ==

    ++  open
      ^-  twig
      ?-    gen
          [%cnhp *]
        :+  %tsls  q.gen
        :+  %tsgl  [%cnzy %$]
        [%cnhp [[%& 2] ~] [[[%& 6] ~] [%tsgl [~ 3] p.gen]] ~]
      ==

This also is not terribly readable.  Let's translate it into the
code that we'd write if we were writing this macro out by hand:

```
=<  =+  deq               ::  create the gate
    $.-(+< =>(+ a))       ::  replace the sample and invoke
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
```

Compare this to the working example above.  The main difference
is that this is what a Lisp fan would call a "hygienic macro."
It does not create private symbols of its own, or if it does they
are not visible to the programmer.  For instance, when we write

    =+  deq

instead of

    =+  foo=deq

we see how wrong it is to think of the latter as "declaring a
variable `foo` and assigning it to `deq`."  Actually, we have no
need within a synthetic hoon to bind a name.  After the `=+`, we
can reach the gate with just `-`. 

But we cannot simply replace the sample with `a` - because the
programmer who wrote `a` meant to write a twig against the
original subject, not against the cell of gate and subject.

Fortunately, `=>(+ a)` gets us our original subject back - and
`%-` works exactly as if it was a natural hoon.  That's hygiene.

###Sequel hook###

So is this the right way to write decrement (assuming we didn't
already have decrement)?  No - there is actually a hoon designed
specifically for building gates.  

The right code (which we saw earlier) is:

```
=<  (deq a)
|%
++  deq
  |=  x=@
  =|  y=@
  |-  ?:  =(x +(y))
        y
      $(y +(y))
--
```

But this requires us to understand `x=@` - which *isn't even a
twig*.  Rather, it's something else, called a `tile`.  We'll make
friends with the tiles in the next chapter.

For those with classic FP experience, it's very tempting to read
`|=` (`bartis`, `%brts`) as "lambda."  I hope it's clear by now
that the difference between Hoon and classic FP languages is like
the difference between a bat and a bird.  Both have wings and use
them to fly, but below that level everything is different.
