<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>The blog of Urbit</title>
 <link href="http://urbit.org/atom.xml" rel="self"/>
 <link href="http://urbit.org"/>
 <updated>2013-09-25T18:19:02-04:00</updated>
 <id>http://urbit.org</id>
 <author>
   <name>Urbit</name>
   <email>urbit@urbit.org</email>
 </author>

 
 <entry>
   <title>Continuity Timeframe</title>
   <link href="http://urbit.org/2013/09/25/continuity.html"/>
   <updated>2013-09-25T15:00:00-04:00</updated>
   <id>http://urbit.org/2013/09/25/continuity</id>
   <content type="html">&lt;p&gt;Thought we&amp;#8217;d share the following email that we sent out on the developers mailing list (urbit-dev@googlegroups.org):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Welcome to Urbit! You&amp;#8217;ve been added to this mailing list because you all are now proud owners of one or more destroyers (let us know if you&amp;#8217;re not and we&amp;#8217;ll remedy that). We&amp;#8217;ll be using this list to update all of you with the latest news from the offworld colonies. Presently your subscription settings are at one digest email daily (we have a powerful hatred of listserv-spam). Feel free to change these settings on Google Groups to whatever you like.&lt;/p&gt;

&lt;p&gt;Our target date for network continuity is Friday October 4th. At which point the data structures we create will (if we succeed) live forever. We&amp;#8217;ll almost certainly do at least one reboot sometime before then, so you&amp;#8217;ll have to recreate your destroyers from your keys when we do.&lt;/p&gt;

&lt;p&gt;Also, we plan on putting up some actual Hoon doc by then, so you all can, you know, actually learn Hoon.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;ll leave you with some Borges: &amp;#8220;Stranger and more pure than any hron is, at times, the ur: the object produced through suggestion, educed by hope.&amp;#8221;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since this blog post is not limited to 1000 words (seriously Google) and because I love that quote so damn much, I&amp;#8217;ll post the whole thing:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;#8220;In the most ancient regions of Tl√∂n, the duplication of lost objects is not infrequent. Two persons look for a pencil; the first finds it and says nothing; the second finds a second pencil, no less real, but closer to his expectations. These secondary objects are called hronir and are, though awkward in form, somewhat longer. Until recently, the hronir were the accidental products of distraction and forgetfulness. It seems unbelievable that their methodical production dates back scarcely a hundred years, but this is what the Eleventh Volume tells us.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&amp;#8230;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The methodical fabrication of hronir (says the Eleventh Volume) has performed prodigious services for archaeologists. It has made possible the interrogation and even the modification of the past, which is now no less plastic and docile than the future. Curiously, the hronir of second and third degree - the hronir derived from another hron, those derived from the hron of a hron - exaggerate the aberrations of the initial one; those of fifth degree are almost uniform; those of ninth degree become confused with those of the second; in those of the eleventh there is a purity of line not found in the original. The process is cyclical: the hron of the twelfth degree begins to fall off in quality. Stranger and more pure than any hron is, at times, the ur: the object produced through suggestion, educed by hope.&amp;#8221;&lt;/p&gt;
&lt;/blockquote&gt;</content>
 </entry>
 
 <entry>
   <title>Welcome to Urbit</title>
   <link href="http://urbit.org/2013/09/24/urbit-intro.html"/>
   <updated>2013-09-24T15:00:00-04:00</updated>
   <id>http://urbit.org/2013/09/24/urbit-intro</id>
   <content type="html">&lt;p&gt;But wait - what the hell is Urbit?&lt;/p&gt;

&lt;p&gt;One of Urbit&amp;#8217;s problems is that we don&amp;#8217;t exactly have a word for what Urbit is. If there is such a word, it somehow means both &amp;#8220;operating system&amp;#8221; and &amp;#8220;network protocol,&amp;#8221; while somehow also implying &amp;#8220;functional&amp;#8221; and &amp;#8220;deterministic.&amp;#8221;&lt;/p&gt;

&lt;p&gt;Not only is there no such word, it&amp;#8217;s not even clear there &lt;em&gt;should&lt;/em&gt; be one. And if there was, could we even hear it? As Wittgenstein said: if a lion could talk, we would not understand him. But heck, let&amp;#8217;s try anyway.&lt;/p&gt;

&lt;p&gt;As a network protocol, we could call Urbit a &amp;#8220;seven-layer protocol&amp;#8221; - that is, a protocol that specifies the complete semantics of the general-purpose computer that processes it. As any decent IETF ninja will tell you, this is a very bad idea for all sorts of extremely obvious reasons.&lt;/p&gt;

&lt;p&gt;And from the OS perspective, Urbit is yet another slice of userspace crap with the temerity to call itself an &amp;#8220;operating system.&amp;#8221; Urbit is not actually an OS in the bare-metal sense. It&amp;#8217;s a VM that runs on Linux or OS X. Someday it might be so daring as to descend to Xen. Urbit has no interest at all in drivers, peripherals, etc. It is just a UDP transceiver in the cloud. Worst of all - Urbit is not even preemptive. A poser! (Actually all the real work, as in node, is done by libuv.)&lt;/p&gt;

&lt;p&gt;Moreover, this VM is formally isolated from your actual OS. And everything that uses it. Nothing in Urbit can request system services or call existing libraries. So Urbit is not only badly designed and fraudulently hyped. It&amp;#8217;s also profoundly useless.&lt;/p&gt;

&lt;p&gt;Well&amp;#8230; your browser has been reasonably successful with this restriction. But your browser was never designed to be any kind of OS. To the extent that it&amp;#8217;s sort of become an OS, it is specialized for the very undemanding job of being a client. A general-purpose client, which is neat. But not a general-purpose server - which is a much harder problem.&lt;/p&gt;

&lt;p&gt;A general-purpose server is a slab of code that feels totally confident when faced with the problem of storing &lt;em&gt;all your personal and/or corporate data&lt;/em&gt;, across &lt;em&gt;arbitrary functional upgrades&lt;/em&gt;, for &lt;em&gt;all time forever&lt;/em&gt;, while efficiently executing and managing &lt;em&gt;any useful program or programs, transient or persistent&lt;/em&gt;. Yeah, that&amp;#8217;s a server OS.&lt;/p&gt;

&lt;p&gt;So, conventionally, this industrial strength slab of code is written with conventional OS techniques involving (a) bare metal and (b) like, semaphores and shit. The kernel alone is like 12 million lines of code. Not that a browser is any much smaller.&lt;/p&gt;

&lt;p&gt;And so, 20th-century network computing is the world&amp;#8217;s most beautiful wire, between two dumpsters of shit spaghetti. Two &lt;em&gt;completely different&lt;/em&gt; dumpsters. It turns out that with a big enough dumpster of shit spaghetti, you can feed the world. And why not two? Incompatibility creates jobs, you know.&lt;/p&gt;

&lt;p&gt;Oh, and you can have a client without an identity. But you can&amp;#8217;t have a &lt;em&gt;server&lt;/em&gt; without an identity. So Urbit has to solve &lt;em&gt;that&lt;/em&gt; problem. Unless it&amp;#8217;s just going to be a Web server. (Urbit is actually a perfectly decent Web server.) Unless it has an actual identity model, your general-purpose server - presumably a &lt;em&gt;network&lt;/em&gt; server - has no network effect. No identity, no network. No network, who the hell cares?&lt;/p&gt;

&lt;p&gt;And unlike your ordinary, common or garden Web application server, Urbit does need that network effect. You see, it&amp;#8217;s not even our own work. It&amp;#8217;s something we found. On an unmarked USB stick by the side of the road three kilometers from Area 51.&lt;/p&gt;

&lt;p&gt;We think it&amp;#8217;s probably still human engineering. First of all, there are no aliens. Second, Urbit uses Unicode. Do the aliens have Unicode? Or SHA-256? &lt;em&gt;Where did Unicode come from, anyway?&lt;/em&gt; And at the I/O level, we see UDP, HTTP, etc. The command line does Emacs keys. At the very least, someone on Earth (or at least &lt;em&gt;from&lt;/em&gt; Earth) has done some porting.&lt;/p&gt;

&lt;p&gt;But other than these cosmetic details, there&amp;#8217;s not much sign of a connection to ordinary Earth computing. For instance, Urbit isn&amp;#8217;t written in any of our Earth languages. It is written in something called Hoon, which is a strict, higher-order, typed functional language - but has nothing in else in common with other Earth languages, functional or not. Hoon does not even use standard PL theory. And its syntax is just as alien, although at least it confines itself to the ASCII plane. (And you probably thought the &amp;#8220;A&amp;#8221; in &amp;#8220;ASCII&amp;#8221; stood for &amp;#8220;American.&amp;#8221;)&lt;/p&gt;

&lt;p&gt;Worse yet, Hoon is not written in anything normal. It&amp;#8217;s written in Hoon. To be precise - the Hoon compiler compiles itself to a much simpler automaton, Nock. Besides machine language itself, and its various bytecode homages, there are three simple formal models of computing - Turing machines, lambda calculus, and Chuck Moore. There is also a fourth which no one has ever found useful for anything: combinators. Nock is a combinator automaton.&lt;/p&gt;

&lt;p&gt;While nowhere near the simplest such automaton known, and certainly not of any &lt;em&gt;theoretical&lt;/em&gt; interest, Nock is so stupid that if you gzip the spec, it&amp;#8217;s only 374 bytes. Nock&amp;#8217;s only arithmetic operation is increment. So decrement is an &lt;code&gt;O(n)&lt;/code&gt;, operation; add is &lt;code&gt;O(m*n)&lt;/code&gt;&amp;#8230;&lt;/p&gt;

&lt;p&gt;Clearly not a practical system. Even if this&amp;#8230; &lt;em&gt;thing&lt;/em&gt;&amp;#8230; that sits on top of it was in any way, shape or form remotely sane.&lt;/p&gt;

&lt;p&gt;So why not try it? Heck, why not at least check it out? Strange and foolish dreamers may hie themselves to teh github:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#39;https://github.com/urbit&#39;&gt;https://github.com/urbit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Various people have built and run Urbit on Ubuntu, Homebrew and MacPorts. It&amp;#8217;s possible that all these people were stone cold ninjas. Urbit is a pretty cool toy, I think, if you&amp;#8217;re a ninja. Unfortunately it is not really ready for ordinary rice farmers. If you can&amp;#8217;t resolve build dependencies by hand, we&amp;#8217;re sorry. Urbit is probably not yet ready for you.&lt;/p&gt;

&lt;p&gt;Where should you run Urbit? Ideally, in the cloud. Urbit can punch a decent NAT hole. It doesn&amp;#8217;t like to, though - what does? Bear in mind that your Urbit instance is a single-level store - your state is saved as a log and a checkpoint (as in Redis - except that Redis is both fast and reliable). This will work much better on server hardware. That said, there are plenty of good reasons to keep your servers in the closet with the plants.&lt;/p&gt;

&lt;p&gt;Next, you need a ticket. Or not. You at least need to decide whether you want a ticket or not. Actually, the answer is simple. You do want one. But you don&amp;#8217;t need one - not yet.&lt;/p&gt;

&lt;p&gt;Because Urbit, the OS, never depends on Earth semantics, it needs its own network protocol - Ames. Ames is a P2P protocol with its own public-key infrastructure. (Ames is encrypted, but the current cryptosuite, suite A, is worthless snakeoil. Don&amp;#8217;t trust it with your Trader Joe receipts.) Ames runs over UDP, and pays as little attention to IP routing as possible. Needless to say, Urbit does not use the DNS at all.&lt;/p&gt;

&lt;p&gt;To sling packets on Ames, you need an identity. Needless to say, there are a lot of ways to do distributed cryptographic identity, all of them bad.&lt;/p&gt;

&lt;p&gt;The general reason all PKIs suck is called &amp;#8220;Zooko&amp;#8217;s Triangle.&amp;#8221; Your identities can be distributed, secure, or human-meaningful - pick any two. There is no way to solve Zooko&amp;#8217;s Triangle. The only way to attack it is to compromise on at least one vertex.&lt;/p&gt;

&lt;p&gt;To see how Urbit works, let&amp;#8217;s start with a standard solution. An Urbit identity is called a &amp;#8220;ship.&amp;#8221; You can launch your own ship by generating a 2048-bit RSA key and hashing it to a 128-bit fingerprint, which is your identity. This trivial design is the basis of all distributed, secure PKIs.&lt;/p&gt;

&lt;p&gt;Unfortunately, an identity should be above all a &lt;em&gt;name&lt;/em&gt;. A 128-bit fingerprint looks like this:&lt;/p&gt;

&lt;p&gt;which isn&amp;#8217;t a name. For no better reason than the fact that, unless you&amp;#8217;re an autistic savant, you are basically a monkey with an overgrown monkey brain. A name is something that fits in a register. Your monkey brain doesn&amp;#8217;t have 128-bit registers.&lt;/p&gt;

&lt;p&gt;Suppose we could use 64-bit fingerprints? At first this seems even less promising. First of all, your monkey brain doesn&amp;#8217;t have 64-bit registers, either. Second, at 64 bits, collisions are already a real problem.&lt;/p&gt;

&lt;p&gt;But we can solve both these problems. Your monkey brain doesn&amp;#8217;t have 64-bit registers. But anything that lets us do 64-bit identities might stretch down to 32 bits. And at 64 or 32 bits, we can&amp;#8217;t assign identities by random hash. So we&amp;#8217;ll have to find another way of distributing them.&lt;/p&gt;

&lt;p&gt;A 32-bit identity - or even a 16-bit identity - will still never be human-meaningful. Perhaps we can make it human-memorable. Meaningful addresses are a nice feature in a social network, but memorable addresses are essential. And if we have memorable addresses, perhaps we can build meaningful names on top.&lt;/p&gt;

&lt;p&gt;The classic example of a memorable address is a street address. Your street address identifies you precisely, using a name. You have this great brain hardware for remembering names. But what does the name of your street &lt;em&gt;mean&lt;/em&gt;? Nothing at all, usually. And even if it does mean something, by accident or design, that meaning has nothing at all to do with you. (One of us grew up in Columbia, Maryland, which has street names like &amp;#8220;Greek Boy Place.&amp;#8221;)&lt;/p&gt;

&lt;p&gt;So all we need is a simple, tasteful, memorable way to remember 32 bits - and we&amp;#8217;re on our way to approximating the Triangle.&lt;/p&gt;

&lt;p&gt;Decimal notation is the worst way of remembering a 32-bit number. IP notation is a little better. Urbit has a typically crude approach: we map every byte to a CVC phoneme, making names like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   ~tasfyn-partyv
   ~sivbud-barnel
   ~tomsyt-balsen&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These strings, while quite meaningless, are no less memorable than real human names in many a language. Moreover, they form a language of their own, and become more memorable as you use them. And there are 4 billion of them, which (as we&amp;#8217;ll see) is almost exactly the right number.&lt;/p&gt;

&lt;p&gt;But how do we distribute them? One obvious solution is a proof of work scheme, as in Bitcoin. Coordinating a global proof-of-work scheme is quite nontrivial, however. Also, there is a second reason to compromise 100% decentralization: packet routing. It might be possible to use a blockchain as a global routing table. It would take some thinking about.&lt;/p&gt;

&lt;p&gt;Furthermore, there&amp;#8217;s a clue here that the Bitcoin approach just isn&amp;#8217;t getting. The limited subspace of short names, within the general space of 128-bit names, is essentially &lt;em&gt;real estate&lt;/em&gt;. There is absolutely no reason, moral or practical, to give this real estate away for free to people whose only contribution is generating CO2 on their GPUs. Mining is not in any way a productive activity.&lt;/p&gt;

&lt;p&gt;Rather, initially, this real estate belongs to Urbit itself. If Urbit has value, its real estate has value. If Urbit has no value, its so-called real estate is a bunch of worthless bits. Therefore, any value in the real estate can, should, and will be used to bootstrap the system from an economic perspective. Ie, it belongs to and will be captured by Urbit&amp;#8217;s developers and/or early adopters. If you find this morally wrong, sorry. You&amp;#8217;re probably some kind of a communist.&lt;/p&gt;

&lt;p&gt;But because Urbit is a free republican society - not (ahem) a fascist corporate dictatorship like Google, Facebook or Twitter - a crucial aspect of launching or transferring a ship is that the decision is irreversible.&lt;/p&gt;

&lt;p&gt;As the master of an Urbit ship, your informal title is cryptographic and &lt;em&gt;allodial&lt;/em&gt; - no one, not the government and certainly not us, can challenge it. Unless the attacker can steal your secrets. In which case, of course, she might as well be you. That&amp;#8217;s like Bitcoin too.&lt;/p&gt;

&lt;p&gt;If Bitcoin is money, Urbit is land. (Floating land is still land, if there&amp;#8217;s a limited amount of it.) You own both in the same way, by proving you can keep a secret. A Bitcoin is not useful for anything, except selling to a greater fool. (We&amp;#8217;re just kidding - we&amp;#8217;re huge Bitcoin fans.) But an Urbit ship is directly useful, so long as Urbit itself is useful.&lt;/p&gt;

&lt;p&gt;You fill your Bitcoin wallet either by creating new coins, or buying old ones from Satoshi and his cronies. You build your Urbit fleet by buying ships from us and our cronies. (Don&amp;#8217;t ask what we had to do to get them from the aliens. Those aliens are into a lot of strange shit, man.) Ships are transferable, but Urbit is not designed to be a digital currency. Transaction overhead is artificially high. Again, as in real estate.&lt;/p&gt;

&lt;p&gt;Urbit at present is empty and worthless. So 32-bit ships - destroyers - are $0. Launch a 128-bit ship (a submarine) and ask me, ~tasfyn-partyv, for one. We&amp;#8217;ll send you one, two, or a dozen. You can be as anonymous as you want, if you&amp;#8217;re polite. But, if the network lives, a destroyer price will develop. It will be very low at first, but not zero. Urbit is designed to be free as in speech. It&amp;#8217;s not designed to be free as in beer.&lt;/p&gt;

&lt;p&gt;How, cryptographically, are cloud ships distributed? And how are packets routed? The answer is the same - the prefix hierarchy.&lt;/p&gt;

&lt;p&gt;In Urbit&amp;#8217;s naval terminology, ships above 64 bits are &amp;#8220;submarines.&amp;#8221; 64-bit ships are &amp;#8220;yachts.&amp;#8221; 32-bit, &amp;#8220;destroyers.&amp;#8221; 16-bit, &amp;#8220;cruisers.&amp;#8221; 8-bit, &amp;#8220;carriers.&amp;#8221; This also resembles a feudal hierarchy, so it comes with a feudal terminology. There are 256 imperial carriers, 65.280 royal cruisers, 4.294.901.760 rebel destroyers, uncounted scads of private yachts, and more or less infinitely many rogue submarines.&lt;/p&gt;

&lt;p&gt;Every ship but a submarine has a &amp;#8220;will,&amp;#8221; or certificate chain - a linked list of &amp;#8220;deeds.&amp;#8221; The first deed in this list is signed by the ship&amp;#8217;s hierarchical prefix, or &amp;#8220;flagship.&amp;#8221; Mere submarine are independent; carriers create cruisers; cruisers create destroyers; destroyers create yachts.&lt;/p&gt;

&lt;p&gt;A submarine is the fingerprint of its own private key; a carrier&amp;#8217;s fingerprint is predefined in the kernel. Anyone can create any number of 128-bit submarines, whose free and independent society the 64-bit naval hierarchy cannot interfere with. And of course, since Urbit is (a) in the public domain and (b) not patented, anyone can fork Urbit and change the carrier fingerprints. Anyone can also create his own independent and incompatible DNS, but efforts in this direction have not been crowned with great success. In general, the easier it is technically to fork open-source code or an open standard, the less likely a fork is to actually happen.&lt;/p&gt;

&lt;p&gt;An independent ship is an independent reputation. Your flagship hierarchy, though it created your ship, has no control over it - so your reputations are and should be separate. But there are not 2^64 independent reputations in Urbit, only 2^32. Cruisers have no control over the destroyers they create, but yachts have no independence from the destroyers that created them.&lt;/p&gt;

&lt;p&gt;The reason for this is simple - a destroyer corresponds not to a person, but to any institution with its own independent reputation. Yachts are for users, bots, or other sub-identities of this institution. Each destroyer has 2^32 of them, which is, of course, a lot.&lt;/p&gt;

&lt;p&gt;How does independence work in practice? By pinning/TOFU. For any deed number, or &amp;#8220;life,&amp;#8221; the first instance is accepted. Thus when changing secrets, perhaps to transfer a ship, the donor signs a new deed created by the recipient. Once any ship sees this deed, it will never accept another signed by the old owner. Thus, a cruiser cannot sell the same new destroyer twice. Similarly, deed 7 of ~tasfyn-partyv signs deed 8; but no ship which has a deed 8 for ~tasfyn-partyv will either accept deed 7, or any other purported deed 8 which deed 7 later signs.&lt;/p&gt;

&lt;p&gt;Preventing a &amp;#8220;double spend&amp;#8221; thus depends on propagating the latest deed. For this purpose, the ocean is divided into two kinds of ships: friends and non-friends of the ship being transferred. The ship has a list of its cryptographic partners, or &amp;#8220;neighbors,&amp;#8221; for which it holds a symmetric key and a routing (IP) address.&lt;/p&gt;

&lt;p&gt;The new owner sends the new deed to all the neighbors, thus locking the old owner out of them. Future new friends will get the new owner&amp;#8217;s will the same way they get the new owner&amp;#8217;s IP address - by a lookup through the flagship hierarchy. Thus if we update both neighbors and flagship, the old owner is locked out and the new owner is locked in.&lt;/p&gt;

&lt;p&gt;Technically, this is very much an imperfect procedure. It relies on social trust to make it effective. For example, a malicious seller could edit his neighbor list before delivering the ship. You probably don&amp;#8217;t want to buy a used destroyer from someone you distrust. Of course, the same is true of cars.&lt;/p&gt;

&lt;p&gt;And more broadly, the naval hierarchy can and should provide general administrative support. For one thing, the big ships route your packets, at least when establishing contact with your fellow destroyers.&lt;/p&gt;

&lt;p&gt;So - do you want an Urbit destroyer? You know you do. Moreover, they&amp;#8217;re free. Of course, if you are satisfied with a name that looks like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ~machec-binnev-dordeb-sogduc--dosmul-sarrum-faplec-nidted&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can keep swimming around Urbit in your submarine.&lt;/p&gt;

&lt;p&gt;For a while, anyway. Because, besides memorability, there is another reason for short names.&lt;/p&gt;

&lt;p&gt;What&amp;#8217;s neat about short names is that there&amp;#8217;s a finite number of them. This is not a bug, but a feature. Essentially, to borrow the thinking of political scientist James Scott, a finite space is &lt;em&gt;governable&lt;/em&gt;. An infinite space is ungovernable.&lt;/p&gt;

&lt;p&gt;If there are an infinite number of identities, there is no way for anyone to distinguish between a new user and a banned user. A reputation can be punished by destroying it, but anyone can start again at zero. A parasite whose only reason to use the network is to abuse it can keep coming back for more. An email spammer will never run out of addresses to spam from.&lt;/p&gt;

&lt;p&gt;IPv4 is a limited space, which almost but doesn&amp;#8217;t cure spam. The problem is that IPv4 addresses are neither personal nor property, so there is generally no easy way to punish a spammer as he deserves through IP blacklisting. He is very unlikely to be in any sense the owner of the IP address on his packets.&lt;/p&gt;

&lt;p&gt;But if the email address and the IP address were the same thing, and the present fuzzy economic relationship between the user of an IP address were clear and simple, killing spam would become easy. You spam from a destroyer; you go on a list of spammers; no one will accept your unsolicited messages, ever.&lt;/p&gt;

&lt;p&gt;You can get around this. You can buy a new destroyer. But the thing is - it costs you &lt;em&gt;money&lt;/em&gt;. You&amp;#8217;re not spamming for the fun of it. If a destroyer costs a mere $1, the spam you send from it needs to earn you $1.&lt;/p&gt;

&lt;p&gt;This does not make it trivial for the forces of light to hunt you down and render you into processed meat clippings. But it sure as heck evens the game. Who will win? I guess we&amp;#8217;ll see.&lt;/p&gt;

&lt;p&gt;So do you want an Urbit destroyer? Read the &lt;a href=&#39;/2013/08/22/Chapter-1-arvo.html&#39;&gt;documentation&lt;/a&gt; for instructions. Come on, they&amp;#8217;re free&amp;#8230;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Chapter 6 &#58; Security</title>
   <link href="http://urbit.org/2013/08/22/Chapter-6-security.html"/>
   <updated>2013-08-22T00:00:00-04:00</updated>
   <id>http://urbit.org/2013/08/22/Chapter-6-security</id>
   <content type="html">&lt;p&gt;Welcome to Urbit!&lt;/p&gt;

&lt;h1 id=&#39;10_yo_this_is_unfinished_shit&#39;&gt;1.0 YO THIS IS UNFINISHED SHIT!&lt;/h1&gt;

&lt;p&gt;All of the doc herein is cheerfully certified as incorrect, incomplete, misleading and almost certainly misguided. Do not use! Please return to your NSA-certified digital plantation. If you found this site by accident, please keep it to yourself. Clear your hard drive, wipe your search history&amp;#8230; but always trust content from Tlon, Tianming, Urban Republic.&lt;/p&gt;

&lt;h1 id=&#39;20_security&#39;&gt;2.0 Security&lt;/h1&gt;

&lt;p&gt;(Some of the things in this section may not make any sense until you understand the whole Urbit stack. Don&amp;#8217;t worry about it.)&lt;/p&gt;

&lt;p&gt;Never leave security to the end of a project. We&amp;#8217;ve left security to the end of Arvo. Arvo has no security and must not be trusted for anything at all.&lt;/p&gt;

&lt;p&gt;That said, there are five basic security issues in Urbit. Ordered by increasing difficulty:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type 0: securing Urbit ships from the evil Internets&lt;/li&gt;

&lt;li&gt;type 1: securing Urbit ships from each other&lt;/li&gt;

&lt;li&gt;type 2: securing Urbit ships from their own incompetent owners&lt;/li&gt;

&lt;li&gt;type 3: securing Urbit ships from compromised hosting services&lt;/li&gt;

&lt;li&gt;type 4: securing Urbit itself against hostile regimes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Urbit is not hard to secure from the evil world it lives in, if securing it from non-Urbit attacks simply means securing its UDP port against malformed fuzz or DoS traffic that does not follow the Ames protocol. If the input is formally correct, it is not a type 1 attack, but a type 2 attack. You see how we define problems out of existence in this here bar.&lt;/p&gt;

&lt;p&gt;Is it possible to pwn Arvo with malformed input? Try it if you like, ninja. But consider what you&amp;#8217;re up against. First of all, normalizing arbitrary input into a well-typed data structure is the first, most basic layer of protocol security. Hoon&amp;#8217;s type system is designed to solve this problem pretty much the way a gun is designed to shoot bullets at things. Probably your best bet is the outer perimeter where bits become nouns - &lt;code&gt;++cue&lt;/code&gt;, or rather its C jet. But it&amp;#8217;s not exactly a giant attack surface.&lt;/p&gt;

&lt;p&gt;It&amp;#8217;s well known that a hacked computer is always in some sense a &amp;#8220;weird machine.&amp;#8221; Since Arvo is precisely defined in Hoon, which is precisely defined in Nock, which is precisely defined on a T-shirt, it&amp;#8217;s hard work to make it turn weird. Broadly, your best bet is probably to attack the function-specific optimizations (&amp;#8220;jets&amp;#8221;) that &lt;code&gt;vere&lt;/code&gt; uses to implement Nock both efficiently and correctly.&lt;/p&gt;

&lt;p&gt;Jets are written in C, so there&amp;#8217;s something there. On the other hand, jets are not native methods and never make system calls. So we could sandbox/contain the hell out them. (I mean, not that we do. We don&amp;#8217;t. But, we should probably should.)&lt;/p&gt;

&lt;p&gt;The other thing about attacking jets, is that there are two attacks only: you can make the jet compute the wrong result (A), or you can (B) break through it to the OS. Urbit (in theory, not in practice) is pretty good at testing for class A errors. A class A error is quite unlikely to be a general compromise. A class B exploit is very likely to be a general compromise (discounting the sandbox), but almost every class B exploit is also a class A error. So testing for semantic correctness will generally find most exploits.&lt;/p&gt;

&lt;p&gt;Then the crypto itself has to be secure, which means it has to be combs for nano-nits by giga-geniuses with nano-combs. The present cryptosuite (A) is best regarded as a sign reading: &amp;#8220;Crypto Goes Here.&amp;#8221; A can assumed to be crawling with nits of every word size. For example, it does not use a real symmetric encryption function, but crap hand-rolled from a hash. It could be secure, but there are always turds without flies.&lt;/p&gt;

&lt;p&gt;However, as a broader PKI architecture, Ames obeys the two essential rules of crypto: no secret is secret forever, and no algorithm is secure forever. We can and will upgrade the cryptosystem (probably to 25519/AES/SHA3) without rebooting the universe.&lt;/p&gt;

&lt;p&gt;Securing ships from each other is an application-layer problem, not an OS-level problem. Ships don&amp;#8217;t have any inherent power over other ships. Since you always know who you&amp;#8217;re talking to and what you&amp;#8217;re doing, don&amp;#8217;t do anything bad on behalf of anyone malicious. What more could be said?&lt;/p&gt;

&lt;p&gt;The exceptions are pseudo-applications built into Urbit, like the revision control system itself (&lt;code&gt;clay&lt;/code&gt;). Right now, we assume that everyone is a good neighbor, no one is here for anything but silly reasons, and everyone can read everyone else&amp;#8217;s files. But in future, of course, we&amp;#8217;ll need ACLs.&lt;/p&gt;

&lt;p&gt;(Urbit loathes nothing so much as the OAuth approach to network service authentication. Speaking as a network service - don&amp;#8217;t hand me some crypto capability and ask me to prove what rights it conveys. Just tell me who you are, securely. And I&amp;#8217;ll decide what services you&amp;#8217;re entitled to receive. Do you really need to delegate authority to third parties who neither are, nor aren&amp;#8217;t, you? We&amp;#8217;re not on that digital plantation anymore, right?)&lt;/p&gt;

&lt;p&gt;DoS defense between ships - a problem which, stated broadly enough, includes spam - is not as hard as it sounds, because Urbit is not an infinite-identity network. When identities are finite, blacklists/killfiles work, work well, and are easy. We don&amp;#8217;t have them yet because we don&amp;#8217;t need them yet. We will, but we don&amp;#8217;t expect to have to work hard at it.&lt;/p&gt;

&lt;p&gt;Even if a spammer or other malefactor gets his slimy goblin paws on a virgin cruiser or carrier, defining 2^16 or 2^24 destroyers, blocking these entire blocks would obviously be a single operation.&lt;/p&gt;

&lt;p&gt;Also, conveying capital ships to bad actors is a bad action of its own. It is in the interest of every Urbiter, big or little, to attack this problem first at its most basic root: keeping ships, especially cruisers or carriers, out of the hands of bad actors. This barrier cannot be perfect - but, especially at first, it is the most important barrier.&lt;/p&gt;

&lt;p&gt;But who is justice, anyway? Who decides who&amp;#8217;s good or bad? Blacklists are meant to be shared. Who owns the global blacklist? Is there a global blacklist? Or several competing candidates for this near-Papal authority? These are all social, not technical, problems, that Urbit must solve in the long run to succeed. More on this at the type 4 layer.&lt;/p&gt;

&lt;p&gt;Of course, DoS attacks of any sort must be ultimately delegated with a &amp;#8220;squelch upstream source&amp;#8221; request to the hosting provider. We have not even begun to address this protocol, which will by definition only be needed if we succeed.&lt;/p&gt;

&lt;p&gt;But type 2 security is by far the hardest problem. We&amp;#8217;ve punted on this problem completely. Or almost completely.&lt;/p&gt;

&lt;p&gt;The only way to solve the type 2 problem is with strict privilege rings whose definition is extremely precise and permanent. Arvo has three, coded as metals - &lt;code&gt;%lead&lt;/code&gt;, &lt;code&gt;%gold&lt;/code&gt; and &lt;code&gt;%iron&lt;/code&gt;. (To confuse you, these same tokens mean something else totally different in the Hoon type system.)&lt;/p&gt;

&lt;p&gt;An Arvo task, to simplify broadly, is literally a function that accepts an event and returns an effect. Thus, we can define privilege rings in terms of simple filters on these effects.&lt;/p&gt;

&lt;p&gt;Lead privilege, always associated with a single foreign ship, is the equivalent of the origin restriction in the browser. Code is treated as totally untrusted and evil. It cannot have any serious effects on your ship. It can converse only only with its own origin server. This restriction is not implemented. So watch your back!&lt;/p&gt;

&lt;p&gt;Iron privilege is normal operating privilege. This concept is not even defined. So it could not possibly be implemented. And indeed, it isn&amp;#8217;t.&lt;/p&gt;

&lt;p&gt;Gold privilege is root privilege with no restriction at all. Right now, everything you do is &lt;code&gt;%gold&lt;/code&gt;. So watch your back! Anything you run can steal any secret and send it anywhere.&lt;/p&gt;

&lt;p&gt;When these privileges actually work, however, you&amp;#8217;ll set them on the command line by prepending &lt;code&gt;!&lt;/code&gt; to &lt;code&gt;:&lt;/code&gt;, for every level of privilege escalation - or &lt;code&gt;?&lt;/code&gt;, for every level of de-escalation. Default privilege is %iron for local applications and %lead for network ones. Thus,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; !:hello %world
&amp;quot;hello, world.&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;upgrades &lt;code&gt;:hello&lt;/code&gt; to root privilege, basically Arvo&amp;#8217;s &lt;code&gt;sudo&lt;/code&gt;. Privilege-restricted terminals will also exist at some point.&lt;/p&gt;

&lt;p&gt;Finally, it should be obvious that type 3 security is a completely unsolvable problem. If you do not trust your host for social, noncryptographic reasons, you do not trust your host at all. If you don&amp;#8217;t trust your restaurant not to poison your dinner, choose another restaurant. If you don&amp;#8217;t trust any restaurant not to poison your dinner, eat at home. If you don&amp;#8217;t trust anyone to host you, own and operate your own computer.&lt;/p&gt;

&lt;p&gt;Most people eat at restaurants. Most people, we think, will prefer the safety, comfort and efficiency of cloud hosting. On the other hand, it might be argued that these people are fools and sheep, whose their safety and freedom depends on the paranoia of paranoid nutcases who self-host - and thus define a community in which absolute privacy, though not forced on anyone, is instantly available to anyone at any time - at the expense of making a probably suboptimal economic choice.&lt;/p&gt;

&lt;p&gt;In a well-designed secure network, privacy must be available to everyone, but it need not be forced on everyone. Or even turned on by default. Privacy always creates inconvenience, and most users prefer convenience. But the users who are willing to accept a little inconvenience, in exchange for privacy, in the same network, create a sort of herd immunity for everyone.&lt;/p&gt;

&lt;p&gt;When I worry about Urbit and privacy, I worry that it will create too much privacy, rather than too little. Certainly several services not too dissimilar to Urbit, such as Freenet, have become hives of digital vice - at best.&lt;/p&gt;

&lt;p&gt;Only social and political methods, not technical tools, can fight this filth. One of the inspirations for Urbit&amp;#8217;s political design is James C. Scott&amp;#8217;s classic political-science text, &lt;em&gt;Seeing Like a State&lt;/em&gt;. Urbit is not in any sense a state, but its fabric has the regularity that, according to Scott, is essential for the construction of anything like a civilized society. But of course, a basically virtuous society, in which antisocial behavior is not tolerated and easily excluded or destroyed, can only be built from virtuous users.&lt;/p&gt;

&lt;p&gt;Urbit has no central government and does not need one - except possibly for type 4 reasons, which hopefully will never arise. It is cryptographically designed, through the ship hierarchy, to splinter rapidly into multiple highly governable spaces. The structure and nature of these carrier (2^24 destroyers) and cruiser (2^16 destroyer) regimes is entirely unclear. And the cryptographic/routing hierarchy is not the only way to organize distributed institutions; it is just one such way.&lt;/p&gt;

&lt;p&gt;Hopefully most of these institutions will succeed, and few will fail. Escape, even from the ship hierarchy, is an essential principle of Urbit. For example, the state of a pier is simply an initial kernel, an event log and a memory image, and the image can be computed from the kernel and the log. The only semantic standards which bind these files are (a) Nock and (b) the Hoon noun-to-atom reduction (++jam), ie, two pages of code. Thus the piers should be portable at the hosting layer.&lt;/p&gt;

&lt;p&gt;But they must also be portable at the Urbit layer. One feature missing in the alpha is the power of a destroyer to escape from a malicious carrier or cruiser in its hierarchy. Most of the value of big ships is simply their hypothetical real estate, but P2P routing could not function without the hierarchy or something similar. Complete exit rights at the destroyer level (a yacht has no exit rights, because a yacht is essentially a user of a destroyer, and shouldn&amp;#8217;t come weirdly unleashed from its owner) require high-level exception lists not yet implemented. The hope is that once this mechanism exists, it will never be used - but if it keeps not existing, that will become a problem.&lt;/p&gt;

&lt;p&gt;Urbit may also become a tool for political sedition. This we don&amp;#8217;t want. One goal of the banner system is to control and subdue illegal political content, such as hate speech on Twitter. Another goal is to organize legal antigovernment communication and organization, as in Occupy or the Tea Party. Ideally, Urbit would be as useful as possible for legal resistance, and as useless as possible for illegal resistance. But of course, as a technology, it is what it is and probably falls short of both.&lt;/p&gt;

&lt;p&gt;Urbit&amp;#8217;s fundamental approach to type 4 security is to comply as enthusiastically as possible with the content regulations of your own jurisdiction and/or community - whether these be political, copyright, or other restrictions. In the type 4 game, the only offense is a good defense. And enthusiastic compliance with all sovereign authorities, de jure or de facto, is the best defense of all - in almost every circumstance.&lt;/p&gt;

&lt;p&gt;At a political level, the banner system is very helpful in this. Most governments are quite comfortable with %blue and %orange political content, but %red content may violate various laws in fascist, nationalist or militarist regimes, and %black in liberal, socialist or communist regimes. Under a regime in which one banner is partly or entirely illegal - even if it is entirely illegal - this &amp;#8220;dangerous&amp;#8221; banner will find it in its own interest to police &lt;em&gt;itself&lt;/em&gt;, and use its own moderation mechanisms to remain jurisdiction-safe. Whatever the rules of the jurisdiction, sensible or otherwise.&lt;/p&gt;

&lt;p&gt;For example, in a jurisdiction where any and all communist speech is illegal, all political speech should be suppressed by the %red banner itself, simply as a matter of communal strategy. In this hypothetical country, it is certainly sufficient provocation for communists to flaunt their own ideology with a %red ship. Not only is suppressing all other political speech the best defense, it may be the best offense as well - for this is essentially the design of a &amp;#8220;color revolution.&amp;#8221; Silence is always unanimous, and power is a function of unanimity.&lt;/p&gt;

&lt;p&gt;At a commercial level, Urbit is certainly not designed to be a file-sharing network or anything of the sort. My advice to content producers, if Urbit ever becomes a thing - or worse yet, achieves the world domination it neither seeks nor fears - is that the right way to fight piracy is to abandon the dangerous and anachronistic practice of sending the same non-watermarked file to everyone. Rather, require every serious content buyer to post a creative bond. If his files are found on a sharing network, he gets a bill and the informer gets a reward. This will have a rapid, lethal effect on the &amp;#8220;culture of sharing.&amp;#8221; But for non-marked files, really nothing can be done.&lt;/p&gt;

&lt;p&gt;Moreover, it is also antisocial to assist others in other jurisdictions from evading local content restrictions, even if these restrictions don&amp;#8217;t apply at all in your jurisdiction. The grievances you create do not dissipate because you are not accessible to the remote governing authority; they pass up the chain and become grievances between that authority and yours. Of course, as with everything, there will be exceptions to this rule that cannot possibly be defined in advance.&lt;/p&gt;

&lt;p&gt;Finally, Urbit is not a digital currency, although Urbit ships have the same basic allodial title model as Bitcoin. Ships are not virtual money - they are virtual real estate. Like real estate, they are designed to be expensive to transfer - a ship can only be transferred 9 times before it loses all its value. This lossage, plus of course poor divisibility, is intended to prevent Urbit ships from being used as a Bitcoin substitute. Rather, use Bitcoin itself (where local laws permit). In theory, Urbit ships are well-suited for both hosting and mining Bitcoin, although there is no such support at present.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Chapter 4 &#58; Hoon - Syntax</title>
   <link href="http://urbit.org/2013/08/22/Chapter-4-syntax.html"/>
   <updated>2013-08-22T00:00:00-04:00</updated>
   <id>http://urbit.org/2013/08/22/Chapter-4-syntax</id>
   <content type="html">&lt;p&gt;Now, let&amp;#8217;s actually look at Hoon. Really, try not to recoil in horror. It&amp;#8217;s actually not anything like line noise.&lt;/p&gt;

&lt;p&gt;Open the Hoon kernel - &lt;code&gt;urb/les/arvo/hoon.hoon&lt;/code&gt;. Let&amp;#8217;s look at the full, official decrement function (line 549):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;++  dec
      ~/  %dec
      |=  a=@
      ^-  @
      ?&amp;lt;  =(0 a)
      =+  b=@
      |-
      ?:  =(a +(b))
        b
      $(b +(b))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whaa?&lt;/p&gt;

&lt;p&gt;Any attempt to understand this in terms of any language you already know would clearly be mistaken. In both syntax and semantics, learning to program in Hoon is learning to program all over again. When we say from scratch, we mean from scratch!&lt;/p&gt;

&lt;p&gt;It&amp;#8217;s actually worse than that - learning Hoon is learning to &lt;em&gt;read&lt;/em&gt; all over again. Hoon is a keyword-free language - any alphanumeric text in the program is part of the program. Where other languages have reserved words, Hoon has squiggles.&lt;/p&gt;

&lt;p&gt;We use so many of these ASCII glyphs that we like to be able to read them out loud. A language is meant to be &lt;em&gt;said&lt;/em&gt;. The squiggles have conventional names, sort of, some of them, some of them easy to say, others not so much. So we&amp;#8217;ve renamed them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ace  space      gal  &amp;lt;          per  )
bar  |          gar  &amp;gt;          sel  [
bas  \          hax  #          sem  ;
buc  $          hep  -          ser  ]
cab  _          kel  {          sig  ~
cen  %          ker  }          soq  &amp;#39;
col  :          ket  ^          tar  *
com  ,          lus  +          tec  `
doq  &amp;quot;          pam  &amp;amp;          tis  =
dot  .          pat  @          wut  ?
fas  /          pel  (          zap  !&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You just have to memorize these names. Sorry.&lt;/p&gt;

&lt;p&gt;But is this at least enough symbols? Alas, nowhere near. ASCII&amp;#8217;s glyph supply is not the greatest, but we can make all the squiggles we need by forming digraphs, or &lt;em&gt;runes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;To pronounce a rune, concatenate the glyph names, stressing the first syllable and softening the second vowel into a &amp;#8220;schwa.&amp;#8221; Hence, to say &lt;code&gt;~.&lt;/code&gt;, say &amp;#8220;sigdot.&amp;#8221; To say &lt;code&gt;|=&lt;/code&gt;, say &amp;#8220;bartis.&amp;#8221; Which has an inevitable tendency to turn into &amp;#8220;barts&amp;#8221; - a sin to be encouraged. In any language actually spoken by actual humans, laziness soon rounds off any rough edges.&lt;/p&gt;

&lt;p&gt;So if we had to read the above decrement, omitting the spaces (which only a real purist would pronounce), we&amp;#8217;d say: &amp;#8220;luslus dec sigfas cen dec bartis a tis pat sigbar soq dec soq ketcab pat wutgal tis pel zero a per tislus b tis pat barhep wutcol tis pel a lus pel b per per b buc pel b lus pel b per per.&amp;#8221; The authorities would then arrive, and drag us out in a big net. Definitely don&amp;#8217;t do this at the airport.&lt;/p&gt;

&lt;p&gt;Geeks being solitary by nature, opportunities for reading code aloud are limited. But studies by actual scientists have shown that even when we read silently, we activate the motor cortex that controls our vocal cords. Even if we never speak these squiggles, they&amp;#8217;re easier to &lt;em&gt;think&lt;/em&gt; if bound to simple sounds.&lt;/p&gt;

&lt;p&gt;(And don&amp;#8217;t worry if you can&amp;#8217;t get yourself to say &amp;#8220;lus&amp;#8221; instead of &amp;#8220;plus&amp;#8221; for &lt;code&gt;+&lt;/code&gt;, or &amp;#8220;tar&amp;#8221; instead of &amp;#8220;star&amp;#8221; for &lt;code&gt;*&lt;/code&gt; - I have this problem myself. It&amp;#8217;s much easier to replace &amp;#8220;underscore&amp;#8221; with &amp;#8220;cab&amp;#8221; or &amp;#8220;ampersand&amp;#8221; with &amp;#8220;pam.&amp;#8221;)&lt;/p&gt;

&lt;p&gt;Hoon has almost 90 digraphic runes. They are easier to organize in your head, though, because the choice of glyph is not random. The second glyph in a rune means little or nothing, but the first defines a rough semantic category. These categories are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|  bar    gates (ie, functions) (ie, one-method cores)
?  wut    conditionals, booleans, tests
:  col    tuples
.  dot    nock operators
$  buc    factory macros (ie, type definitions) 
^  ket    type conversions
=  tis    compositions
%  cen    invocations
&amp;amp;  pam    gears (ie, objects) (ie, multi-method cores)
~  sig    hints
;  sem    miscellaneous macros
!  zap    special operations&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each rune has &lt;em&gt;&lt;span&gt;not&lt;/span&gt;&lt;/em&gt; its own doc file in the &lt;code&gt;rune/190&lt;/code&gt; directory. The name of the file is the name of the rune, minus the vowels. Thus, &lt;code&gt;|=&lt;/code&gt; or &amp;#8220;bartis&amp;#8221; is &lt;em&gt;&lt;span&gt;not&lt;/span&gt;&lt;/em&gt; defined in &lt;code&gt;rune/190/brts.txt&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Opening this file, we see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%brts  |=  &amp;quot;bartis&amp;quot;

  define:
    [%brts p=gene q=gene]

  expand:
    [%brts *]  [%brcb p.gen (~(put by *(map term foot)) %% [%ash q.gen])]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There should be some actual discussion, but there isn&amp;#8217;t. Still, &lt;code&gt;brts.txt&lt;/code&gt; is quite complete as a definition of &lt;code&gt;|=&lt;/code&gt;. How? We need to step back a little.&lt;/p&gt;

&lt;p&gt;When the Hoon parser parses a source file, it generates a noun called a &lt;code&gt;gene&lt;/code&gt;. If you know what an AST is, a gene is an AST node. If you don&amp;#8217;t, don&amp;#8217;t worry about it.&lt;/p&gt;

&lt;p&gt;Search the current kernel for &lt;code&gt;++  gene&lt;/code&gt; - note double space. This code is both the type declaration for type &lt;code&gt;gene&lt;/code&gt;, and a function that maps an untyped noun to a typed gene. In it you&amp;#8217;ll see the above definition,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[%brts p=gene q=gene]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ie, one kind of gene is a triple whose head is the constant &lt;code&gt;%brts&lt;/code&gt;, and whose tail is a pair of genes, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We also see the semantics of this rune: it expands to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[%brcb p.gen (~(put by *(map term foot)) %% [%ash q.gen])]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ie, &lt;code&gt;|=&lt;/code&gt; is a built-in macro. But back to syntax.&lt;/p&gt;

&lt;p&gt;What is &lt;code&gt;%brts&lt;/code&gt;? The atom also known as &lt;code&gt;1937011298&lt;/code&gt; or &lt;code&gt;0x73747262&lt;/code&gt;. Simply a string mapped to an unsigned integer, LSB first. It&amp;#8217;s easy to see why the vowels got lost - &lt;code&gt;%bartis&lt;/code&gt; is &lt;code&gt;126896762413410&lt;/code&gt; or &lt;code&gt;0x736974726162&lt;/code&gt;. On a 32-bit CPU with 31-bit direct atoms, &lt;code&gt;%brts&lt;/code&gt; is direct and &lt;code&gt;%bartis&lt;/code&gt; indirect (not that the programmer can tell the difference). But you still say &amp;#8220;bartis.&amp;#8221;&lt;/p&gt;

&lt;p&gt;For instance, in the decrement above, we have&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|=  a=@
~|  &amp;#39;dec&amp;#39;
^-  @
?&amp;lt;  =(0 a)
=+  b=@
|-
?:  =(a +(b))
  b
$(b +(b))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this &lt;code&gt;%brts&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a=@&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;q&lt;/code&gt; is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~|  &amp;#39;dec&amp;#39;
^-  @
?&amp;lt;  =(0 a)
=+  b=@
|-
?:  =(a +(b))
  b
$(b +(b))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are starting to see the principles of Hoon syntax. Let&amp;#8217;s make them clear.&lt;/p&gt;

&lt;p&gt;First, for any rune, the Hoon parser has two kinds of syntax: normal and custom. Most runes, such as &lt;code&gt;|=&lt;/code&gt;, have only normal syntax without custom syntax. Almost all runes with custom syntax also have normal. Custom can mean anything; normal is rigid and uniform.&lt;/p&gt;

&lt;p&gt;All programming languages, but especially functional ones, face two difficult syntactic problems. One is controlling the large numbers of terminators that appear in any deeply nested tree structure - Lisp is infamous for its piles of right parens. These are not a serious usability problem, except inasmuch as you consider ugly a usability problem (which I do). Two, a more serious concern, is keeping complex routines from flowing off the right margin as tab depth increases.&lt;/p&gt;

&lt;p&gt;A glance at the more complex organs of the Hoon kernel reveals that Hoon is relatively untroubled by either of these woes. But why? One dubious panacea for the terminator problem is the use of significant whitespace. Whitespace in Hoon is not significant. (To be exact, the presence or absence of whitespace matters, but the quantity never does.)&lt;/p&gt;

&lt;p&gt;The answer is that the normal syntax for every rune has two forms: &amp;#8220;wide&amp;#8221; and &amp;#8220;tall.&amp;#8221; As a functional language, Hoon does not distinguish between statements and expressions, but normal wide syntax is expression-like and tall is statement-like.&lt;/p&gt;

&lt;p&gt;For instance, in our example above,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?:  =(a +(b))
  b
$(b +(b))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is a tall normal form. The equivalent wide form is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?:(=(a +(b)) b $(b +(b)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;#8217;s usually best to use the wide form if your gene fits on the line, but this is obviously an aesthetic choice. If your gene does not fit your margin (which should always be 80 columns), you have no choice but to go tall. For reasons that should be obvious, a tall gene can contain wide subgenes, but a wide gene cannot contain tall subgenes - just as, in procedural languages, a statement can contain expressions but not vice versa.&lt;/p&gt;

&lt;p&gt;In the wide normal form, the rune is followed immediately (no whitespace) by a left paren (&amp;#8220;pel&amp;#8221;), then the subgenes with a single space between them, then a right paren (&amp;#8220;per&amp;#8221;) as terminator. If the rune was inside the parens rather than a prefix, this would be the Lisp syntax.&lt;/p&gt;

&lt;p&gt;In the tall normal form, any quantity of whitespace follows the rune, and separates the subgenes from each other. Where is the terminator? There is no terminator - in most cases.&lt;/p&gt;

&lt;p&gt;Consider the &lt;code&gt;?:&lt;/code&gt; rune, &amp;#8220;wutcol,&amp;#8221; &lt;code&gt;%wtcl&lt;/code&gt;. This is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[%wtcl p=gene q=gene r=gene]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why should we need a terminator? We know &lt;code&gt;%wtcl&lt;/code&gt;, whose semantics are if-then-else, has three subgenes. When the parser sees &lt;code&gt;?:&lt;/code&gt; followed by space, it simply parses the next three genes and fills the rune with them.&lt;/p&gt;

&lt;p&gt;This only works in runes with fixed tuple structure, which fortunately is most of them. A counterexample is &lt;code&gt;:*&lt;/code&gt;, ie,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[%cltr p=(list gene)]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is of variable length and needs a terminator. But we have no dangling parens, but an attractive tall closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:*  %foo
        %bar 
        %baz
        %moo
    ==&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;whose equivalent wide normal is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:*(%foo %bar %baz %moo)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which no one would ever write, preferring the custom&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[%foo %bar %baz %moo]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This leaves only one question: indentation. Since space is not significant (even linebreaks are irrelevant - the newline is just another space), the use of whitespace in tall forms is purely a matter of style. Style is very important, however!&lt;/p&gt;

&lt;p&gt;The first law of Hoon indentation style is that all tall indentation is in two-space increments. (Tabs are illegal. If you pollute a Hoon file with ASCII 9, not only will it not parse, but thugs in ski masks will kick down your door and shoot you. You laugh! Try it!) Single spaces are for wide only.&lt;/p&gt;

&lt;p&gt;The second law of Hoon indentation is that everything in the kernel is good indentation style. Or at least if it&amp;#8217;s not, it needs changed. The kernel shall be lapidary, noble, ideal and above all suspicion - a Doric column, a Tlingit totem pole, an Egyptian obelisk.&lt;/p&gt;

&lt;p&gt;Tallness matters. The third law of Hoon indentation is that large genes should flow &lt;em&gt;down&lt;/em&gt; and not &lt;em&gt;across&lt;/em&gt; - like the decrement example above. The right margin is a precious resource not to be wasted. It&amp;#8217;s this law, when properly applied, that makes casual readers wonder if Hoon is a functional language at all. It doesn&amp;#8217;t have a program counter, but it looks like it does - at least when written right.&lt;/p&gt;

&lt;p&gt;In list-structured runes, like the &lt;code&gt;:*&lt;/code&gt; above, there is no choice but to lose right margin. Fortunately, most runes are tuples, and most have limited &amp;#8220;fanout&amp;#8221; - 1, 2, 3 or at most 4.&lt;/p&gt;

&lt;p&gt;Both of our above examples - &lt;code&gt;|=&lt;/code&gt; and &lt;code&gt;?:&lt;/code&gt; - use &amp;#8220;backstep&amp;#8221; indentation which takes advantage of this tuple structure. For instance, &lt;code&gt;|=&lt;/code&gt; has two subgenes, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q.&lt;/code&gt; We put &lt;code&gt;p&lt;/code&gt; on the same line as &lt;code&gt;|=&lt;/code&gt;, set off by two spaces, losing 4 characters of margin. We put &lt;code&gt;q&lt;/code&gt; &lt;em&gt;directly below&lt;/em&gt;, losing no margin at all.&lt;/p&gt;

&lt;p&gt;It so happens that in almost every actual case of &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; (the function&amp;#8217;s argument) is relatively light, whereas &lt;code&gt;q&lt;/code&gt; (the function&amp;#8217;s body) will be much heavier. Thus, with this pattern of indentation, we lose no margin and our code flows &lt;em&gt;down&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;We see this even more in &lt;code&gt;?:&lt;/code&gt;, where the conditional test (which is much less likely to be heavy) is first and farthest right, followed by the &amp;#8220;then&amp;#8221; case indented two spaces, followed by the &amp;#8220;else&amp;#8221; case at the same indent as the rune.&lt;/p&gt;

&lt;p&gt;Suppose your &amp;#8220;else&amp;#8221; is relatively light, and your &amp;#8220;then&amp;#8221; is heavy? You may prefer the &lt;code&gt;?.&lt;/code&gt; rune, Hoon&amp;#8217;s &amp;#8220;unless,&amp;#8221; which puts the else before the then. Or not. And in both &lt;code&gt;?:&lt;/code&gt; and &lt;code&gt;?.&lt;/code&gt;, the test (which of course can be arbitrarily heavy) is first. It is not necessary for your code to &lt;em&gt;always&lt;/em&gt; flow down and not across - just &lt;em&gt;mostly&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The conventional principle which backstep indentation sacrifices, of course, is the idea that absolute indentation depth should correspond to tree depth, loop depth, or some other metric. Hoon is so deeply nested that if tab depth matched tree depth, your margins on anything interesting would be in the next cube to your right. There is perhaps a case for indenting loops, but we don&amp;#8217;t find we miss this cue at all.&lt;/p&gt;

&lt;p&gt;The paucity of terminators also eliminates a lot of redundancy in the parser, which can result in relatively exciting syntax errors. Our experience is that this is seldom a big problem, because there are terminated tall forms and the cascade stops with them. It is often a small problem, however.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Chapter 3 &#58; Hoon - Philosophy</title>
   <link href="http://urbit.org/2013/08/22/Chapter-3-philosophy.html"/>
   <updated>2013-08-22T00:00:00-04:00</updated>
   <id>http://urbit.org/2013/08/22/Chapter-3-philosophy</id>
   <content type="html">&lt;p&gt;Yo, let&amp;#8217;s write some Hoon!&lt;/p&gt;

&lt;p&gt;In this tutorial we&amp;#8217;re going to try to learn Hoon, without first learning either Nock or Arvo. You probably should at least skim the Nock doc though - learning Hoon without understanding Nock is a little like learning C without understanding how a CPU works. It is not easier than knowing both, it&amp;#8217;s harder.&lt;/p&gt;

&lt;p&gt;As for Arvo, all we&amp;#8217;ll use of it here is the power to edit a library and type expressions on the command line. These are not hard things and we&amp;#8217;ll explain them as we go along.&lt;/p&gt;

&lt;p&gt;We&amp;#8217;ll cover Hoon in three sections - philosophy, syntax, and semantics. You should probably just skip to syntax.&lt;/p&gt;

&lt;p&gt;The good news about Hoon is that it compiles itself to Nock in 3400 lines of Hoon. If this number is accurate (it is), Hoon is very expressive, or very simple, or both. (It&amp;#8217;s both.) The bad news is that it really has nothing at all in common, either syntactically or semantically, with anything you&amp;#8217;ve used before.&lt;/p&gt;

&lt;p&gt;In particular, please remember that &lt;em&gt;you are not too stupid&lt;/em&gt; to program in Hoon. Hoon is FP made stupid - for the stupid, by the stupid. (This is the real reason it&amp;#8217;s only 3400 lines.)&lt;/p&gt;

&lt;p&gt;Maybe you&amp;#8217;ve had some bad experiences with a higher-order typed functional language - like Haskell or OCaml. Dare we suspect that these experiences came on one of our nation&amp;#8217;s fine college campuses? Well, we have to admit, Hoon is a higher-order typed functional language. But really, don&amp;#8217;t let this discourage you.&lt;/p&gt;

&lt;p&gt;First, Hoon hasn&amp;#8217;t been to college. Second, at least it&amp;#8217;s strict. And third, we don&amp;#8217;t use any of that PL theory shit. We&amp;#8217;re OS guys. Our mission is not to praise PL, but to drive it out of the CS department with a flaming sword, back to the fundless ghetto of math where it belongs. Hoon is &amp;#8216;street FP.&amp;#8217; The only functional language it gives any real props to is JS. JS sucks, of course, but at least it&amp;#8217;s a player. (Scala is a player too, but it&amp;#8217;s also the size of a blue whale&amp;#8217;s ass.)&lt;/p&gt;

&lt;p&gt;We hope we&amp;#8217;re not being too harsh on PL theory. The fact is that this branch of mathematics (constructive logic or whatever) is a perfectly adequate and remarkably elegant formal description of computing. But, of course, it is not the only such description. And it was originally created for mathematicians, not coders.&lt;/p&gt;

&lt;p&gt;Nor is the math department&amp;#8217;s standard of elegance the only such standard. The programmer has his own design sense, which corresponds more closely to usability in a UI sense. To read a program is to simulate it in your head, and the skill needed to do this revolves around tracing long complex sequences of very simple transformations.&lt;/p&gt;

&lt;p&gt;For these simple transformations, I think, we use a completely different processing path - less a mathematical intution, than a mechanical one. This is why many good C programmers are bad at symbolic math. Of course, we all should be good at all things - but are we? And this is why Hoon is not Haskell.&lt;/p&gt;

&lt;p&gt;For example, it&amp;#8217;s very true and cool that you can represent all data as functions. It&amp;#8217;s also pretty neat that you can take a leak while standing on your head, and you always hit the bowl. To an OS guy it seems more interesting to represent functions as data. Like, you know how to send data over the network. Do you know how to send functions over the network?&lt;/p&gt;

&lt;p&gt;(On the other hand, if only because Hoon is very immature, Haskell is good at many things that Hoon isn&amp;#8217;t good at. For instance, good list/container comprehensions are the pons asinorum of a functional language. Hoon&amp;#8217;s actually kind of suck. This is not (well, mostly not) because Hoon sucks, but because (a) they are some of the oldest library code in the system, and (b) they have never seen either end of a top-notch functional programmer. Despite the fact that category theory can go bite itself, people with more FP experience on more mature languages probably have a lot to contribute here.)&lt;/p&gt;

&lt;p&gt;Anyway. That&amp;#8217;s enough philosophy. Come on, who needs it?&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Chapter 2 &#58; Crash course in Nock</title>
   <link href="http://urbit.org/2013/08/22/Chapter-2-nock.html"/>
   <updated>2013-08-22T00:00:00-04:00</updated>
   <id>http://urbit.org/2013/08/22/Chapter-2-nock</id>
   <content type="html">&lt;p&gt;So let&amp;#8217;s learn Nock! But wait - why learn Nock? After all, we&amp;#8217;re going to be programming in Hoon, not Nock.&lt;/p&gt;

&lt;p&gt;Like JVM bytecode, Nock is as inscrutable as assembly language. In fact, you can think of it as a sort of &amp;#8220;functional assembly language.&amp;#8221; There are sometimes reasons to program in real assembly language. There is never a reason to program in Nock. Except to learn Nock.&lt;/p&gt;

&lt;p&gt;Indeed, it is not necessary for the Hoon programmer to learn Nock. We recommend it strongly, however, because Hoon has a very special relationship with Nock - not unlike the relationship between C and assembly language.&lt;/p&gt;

&lt;p&gt;Just as C is a very shallow layer over the raw CPU, Hoon is a very shallow layer over raw Nock - often little more than a macro. If you try to learn C without understanding the CPU under it, you will be forever bemused by why it works the way it does.&lt;/p&gt;

&lt;p&gt;So let&amp;#8217;s learn Nock! But wait - which Nock? Nock, though more frozen than Walt Disney, does have versions. Nock versions are measured by integer degrees Kelvin, newer being colder. The newest, Nock 5K - roughly the temperature of Neptune. No change is anticipated between 5K and absolute zero, though you never know. Any such change would certainly be quite painful.&lt;/p&gt;

&lt;h1 id=&#39;11_definition&#39;&gt;1.1 Definition&lt;/h1&gt;

&lt;p&gt;The best way to learn Nock is to read the spec and write your own naive interpreter. Here is Nock 5K:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Structures&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A noun is an atom or a cell.  An atom is any natural number.  
A cell is any ordered pair of nouns.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. Pseudocode&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1  ::    nock(a)           *a
2  ::    [a b c]           [a [b c]]
3  ::  
4  ::    ?[a b]            0
5  ::    ?a                1
6  ::    +[a b]            +[a b]
7  ::    +a                1 + a
8  ::    =[a a]            0
9  ::    =[a b]            1
10 ::
11 ::    /[1 a]            a
12 ::    /[2 a b]          a
13 ::    /[3 a b]          b
14 ::    /[(a + a) b]      /[2 /[a b]]
15 ::    /[(a + a + 1) b]  /[3 /[a b]]
16 ::
17 ::    *[a [b c] d]      [*[a b c] *[a d]]
18 ::
19 ::    *[a 0 b]          /[b a]
20 ::    *[a 1 b]          b
21 ::    *[a 2 b c]        *[*[a b] *[a c]]
22 ::    *[a 3 b]          ?*[a b]
23 ::    *[a 4 b]          +*[a b]
24 ::    *[a 5 b]          =*[a b]
25 ::
26 ::    *[a 6 b c d]      *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
27 ::    *[a 7 b c]        *[a 2 b 1 c]
28 ::    *[a 8 b c]        *[a 7 [[7 [0 1] b] 0 1] c]
29 ::    *[a 9 b c]        *[a 7 c [2 [0 1] [0 b]]]
30 ::    *[a 10 [b c] d]   *[a 8 c 7 [0 3] d]
31 ::    *[a 10 b c]]      *[a c]
32 ::
33 ::    =a                =a
34 ::    /a                /a
35 ::    *a                *a&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your interpreter should be no more than a page of code in any language. For extra credit, &lt;code&gt;6&lt;/code&gt;-&lt;code&gt;10&lt;/code&gt; are macros; implement them directly. For extra extra credit, optimize tail calls. To test your code, write a decrement formula b such that &lt;code&gt;*[a b]&lt;/code&gt; is &lt;code&gt;a - 1&lt;/code&gt; for any atomic nonzero &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#39;12_installation&#39;&gt;1.2 Installation&lt;/h1&gt;

&lt;p&gt;The second best way to learn Nock is to boot up your own Arvo virtual computer. Using a Mac with OS X, install Homebrew and add the following packages: &lt;code&gt;gmp&lt;/code&gt;, &lt;code&gt;libsigsegv&lt;/code&gt;, &lt;code&gt;libev&lt;/code&gt;. Then, make. This will produce &lt;code&gt;bin/vere&lt;/code&gt;, the virtual machine.&lt;/p&gt;

&lt;p&gt;To create an Arvo computer, you need an Urbit identity (seat). In theory, a computer can host one or more seats; in practice, one is the right number.&lt;/p&gt;

&lt;p&gt;There are two ways to get a seat - you can make your own or you can get an invitation. If you make your own, your seat is a 128-bit hash of an RSA public key. If you get an invitation, it&amp;#8217;s a 32-bit number. Either way, that number is encoded in a phonetic base designed to make it easy to remember. So if it&amp;#8217;s a 128-bit seat or &lt;code&gt;pawn&lt;/code&gt;, it looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ralnyl-panned-tinmul-winpex--togtux-ralsem-lanrus-pagrup&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if it&amp;#8217;s a 32-bit seat, it looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have an invitation file, create a computer by running&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vere -i $file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise, generate a 1024-bit RSA key with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vere -n 10&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is just a toy for now, so use the defaults to generate a passcode stored in your home directory. Write this passcode down on a piece of paper if you&amp;#8217;re especially concerned.&lt;/p&gt;

&lt;p&gt;In either case, this generates a directory in &lt;code&gt;hub/&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hub/ralnyl-panned-tinmul-winpex--
hub/tasfyn-partyv&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quit vere with ^D, then restart with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vere $directory&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how you start your computer. Arvo is a single-level store which works by remembering all its events. It should also checkpoint its memory but doesn&amp;#8217;t, so restarting may be quite slow if you have a lot of events. To reset, &lt;code&gt;vere -R.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In $directory are two things - a filesystem tree and an event log (&lt;code&gt;~egz.hope&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Files in the tree are mirrored in Arvo&amp;#8217;s revision control system, with changes detected automagically. So, even though Arvo cannot read the Unix filesystem, you can edit files externally and use them within Arvo. (At present the change detection is not actually magic, but will happen every time you hit return on the command line.)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~egz.hope&lt;/code&gt; contains your events, encrypted with your passcode. Every keypress on the command line, filesystem change, network packet, etc, is in this file. Since it is encrypted, you can check it into a public github repo or similar.&lt;/p&gt;

&lt;p&gt;Now we&amp;#8217;re ready to continue and learn Nock.&lt;/p&gt;

&lt;h1 id=&#39;13_nock&#39;&gt;1.3 Nock&lt;/h1&gt;

&lt;p&gt;To make Nock make sense, let&amp;#8217;s work through Nock 5K line by line. First the data model:&lt;/p&gt;

&lt;h2 id=&#39;1_structures&#39;&gt;1. Structures&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;A noun is an atom or a cell.  An atom is any natural number.
A cell is any ordered pair of nouns.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nouns are the dumbest data model ever. Nouns make JSON look like XML and XML look like ASN.1. It may also remind you of Lisp&amp;#8217;s S-expressions - you can think of nouns as &amp;#8220;S-expressions without the S.&amp;#8221;&lt;/p&gt;

&lt;p&gt;To be exact, a noun &lt;em&gt;is&lt;/em&gt; an S-expression, except that classic S-expressions have multiple atom types (&amp;#8221;S&amp;#8221; is for &amp;#8220;symbol&amp;#8221;). Since Nock is designed to be used with a higher-level type system (such as Hoon&amp;#8217;s), it does not need low-level types. An atom is just an unsigned integer of any size.&lt;/p&gt;

&lt;p&gt;For instance, it&amp;#8217;s common to represent strings (or even whole text files) as atoms, arranging them LSB first - so &amp;#8220;foo&amp;#8221; becomes &lt;code&gt;0x6f6f66&lt;/code&gt;. How do we know to print this as &amp;#8220;foo&amp;#8221;, not &lt;code&gt;0x6f6f66&lt;/code&gt;? We need external information - such as a Hoon type. Similarly, other common atomic types - signed integers, floating point, etc - are all straightforward to map into atoms.&lt;/p&gt;

&lt;p&gt;It&amp;#8217;s also important to note that, unlike Lisp, Nock cannot create cyclical data structures. It is normal and common for nouns in a Nock runtime system to have acyclic structure - shared subtrees. But there is no Nock computation that can make a child point to its parent. One consequence: Nock has no garbage collector. (Nor can dag structure be detected, as with Lisp &lt;code&gt;eq&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;There is also no single syntax for nouns. If you have nouns you have Nock; if you have Nock you have Hoon; if you have Hoon, you can write whatever parser you like.&lt;/p&gt;

&lt;p&gt;Let&amp;#8217;s continue:&lt;/p&gt;

&lt;h2 id=&#39;2_pseudocode&#39;&gt;2. Pseudocode&lt;/h2&gt;

&lt;p&gt;It&amp;#8217;s important to recognize that the pseudocode of the Nock spec is just that: pseudocode. It looks a little like Hoon. It isn&amp;#8217;t Hoon - it&amp;#8217;s just pseudocode. Or in other words, just English. At the bottom of every formal system is a system of axioms, which can only be written in English. (Why pseudocode, not Hoon? Since Hoon is defined in Nock, this would only give a false impression of nonexistent precision.)&lt;/p&gt;

&lt;p&gt;The logic of this pseudocode is a pattern-matching reduction, matching from the top down. To compute Nock, repeatedly reduce with the first line that matches. Let&amp;#8217;s jump right in!&lt;/p&gt;

&lt;h2 id=&#39;line_1&#39;&gt;Line 1:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1  ::    [a b c]           [a [b c]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ie, brackets (in our pseudocode, as in Hoon) associate to the right. For those with Lisp experience, it&amp;#8217;s important to note that Nock and Hoon use tuples or &amp;#8220;improper lists&amp;#8221; much more heavily than Lisp. The list terminator, normally 0, is never automatic. So the Lisp list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(a b c)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;becomes the Nock noun&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[a b c 0]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[a [b [c 0]]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we can and do use unnecessary brackets anyway, for emphasis.&lt;/p&gt;

&lt;h2 id=&#39;line_2&#39;&gt;Line 2:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;2  ::    nock(a)           *a&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nock is a pure (stateless) function from noun to noun. In our pseudocode (and only in our pseudocode) we express this with the prefix operator &lt;code&gt;*&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This function is defined for every noun, but on many nouns it does nothing useful. For instance, if &lt;code&gt;a&lt;/code&gt; is an atom, &lt;code&gt;*a&lt;/code&gt; reduces to&amp;#8230; &lt;code&gt;*a&lt;/code&gt;. In theory, this means that Nock spins forever in an infinite loop. In other words, Nock produces no result - and in practice, your interpreter will stop.&lt;/p&gt;

&lt;p&gt;(Another way to see this is that Nock has &amp;#8220;crash-only&amp;#8221; semantics. There is no exception mechanism. The only way to catch Nock errors is to simulate Nock in a higher-level virtual Nock - which, in fact, we do all the time. A simulator (or a practical low-level interpreter) can report, out of band, that Nock would not terminate. It cannot recognize all infinite loops, of course, but it can catch the obvious ones - like &lt;code&gt;*42&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Normally &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;nock(a)&lt;/code&gt; is a cell &lt;code&gt;[s f]&lt;/code&gt;, or as we say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[subject formula]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Intuitively, the formula is your function and the subject is its argument. We call them something different because Hoon, or any other high-level language built on Nock, will build its own function calling convention which &lt;em&gt;does not&lt;/em&gt; map directly to &lt;code&gt;*[subject formula]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;#8217;s move on to the axiomatic functions.&lt;/p&gt;

&lt;h2 id=&#39;lines_49&#39;&gt;Lines 4-9:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;4  ::    ?[a b]            0
5  ::    ?a                1
6  ::    +[a b]            +[a b]
7  ::    +a                1 + a
8  ::    =[a a]            0
9  ::    =[a b]            1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we define more pseudocode operators, which we&amp;#8217;ll use in reductions further down. So far we have four built-in functions: &lt;code&gt;*&lt;/code&gt; meaning Nock itself, &lt;code&gt;?&lt;/code&gt; testing whether a noun is a cell or an atom, &lt;code&gt;+&lt;/code&gt; incrementing an atom, and &lt;code&gt;=&lt;/code&gt; testing for equality. Again, no rocket science here.&lt;/p&gt;

&lt;p&gt;We should note that in Nock and Hoon, &lt;code&gt;0&lt;/code&gt; (pronounced &amp;#8220;yes&amp;#8221;) is true, and &lt;code&gt;1&lt;/code&gt; (&amp;#8220;no&amp;#8221;) is false. Why? It&amp;#8217;s fresh, it&amp;#8217;s different, it&amp;#8217;s new. And it&amp;#8217;s annoying. And it keeps you on your toes. And it&amp;#8217;s also just intuitively right.&lt;/p&gt;

&lt;h2 id=&#39;lines_1115&#39;&gt;Lines 11-15:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;11 ::    /[1 a]            a
12 ::    /[2 a b]          a
13 ::    /[3 a b]          b
14 ::    /[(a + a) b]      /[2 /[a b]]
15 ::    /[(a + a + 1) b]  /[3 /[a b]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Slightly more interesting is our tree numbering. Every noun is of course a tree. The &lt;code&gt;/&lt;/code&gt; operator - pronounced &amp;#8220;slot&amp;#8221; - imposes an address space on that tree, mapping every nonzero atom to a tree position.&lt;/p&gt;

&lt;p&gt;1 is the root. The head of every node &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;2n&lt;/code&gt;; the tail is &lt;code&gt;2n+1&lt;/code&gt;. Thus a simple tree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     1
  2      3
4   5  6   7
         14 15&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the value of every leaf is its tree address, this tree is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[4 5] [6 14 15]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and, for some examples of addressing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/[1 [[4 5] [6 14 15]]] &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is &lt;code&gt;[[4 5] [6 14 15]]]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/[2 [[4 5] [6 14 15]]]	&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is &lt;code&gt;[4 5]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/[3 [[4 5] [6 14 15]]]  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is &lt;code&gt;[6 14 15]&lt;/code&gt;, and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/[7 [[4 5] [6 14 15]]]  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is &lt;code&gt;[14 15]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I do hope this isn&amp;#8217;t so terribly hard to follow.&lt;/p&gt;

&lt;h2 id=&#39;line_19&#39;&gt;Line 19:&lt;/h2&gt;

&lt;p&gt;Now we enter the definition of Nock itself - ie, the &lt;code&gt;*&lt;/code&gt; operator.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;19 ::    *[a 0 b]          /[b a]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;0&lt;/code&gt; is simply Nock&amp;#8217;s tree-addressing operator. Let&amp;#8217;s try it out from the Arvo command line.&lt;/p&gt;

&lt;p&gt;Note that we&amp;#8217;re using Hoon syntax here. Since we do not use Nock from Hoon all that often (it&amp;#8217;s sort of like embedding assembly in C), we&amp;#8217;ve left it a little cumbersome. In Hoon, instead of writing &lt;code&gt;*[a 0 b]&lt;/code&gt;, we write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.*(a [0 b])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, to reuse our slot example, let&amp;#8217;s try the interpreter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*([[4 5] [6 14 15]] [0 7])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gives, while the sky remains blue and the sun rises in the east:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[14 15]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even stupider is line 19:&lt;/p&gt;

&lt;h2 id=&#39;line_20&#39;&gt;Line 20:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;20 ::    *[a 1 b]          b&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;1&lt;/code&gt; is the constant operator. It produces its argument without reference to the subject. So&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(42 [1 153 218])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;yields&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[153 218]&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#39;line_21&#39;&gt;Line 21:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;21 ::    *[a 2 b c]        *[*[a b] *[a c]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Line 21 brings us the essential magic of recursion. &lt;code&gt;2&lt;/code&gt; is the Nock operator. If you can compute a subject and a formula, you can evaluate them in the interpreter. In most fundamental languages, like Lisp, &lt;code&gt;eval&lt;/code&gt; is a curiosity. But Nock has no &lt;code&gt;apply&lt;/code&gt; - so all our work gets done with &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;#8217;s convert the previous example into a stupid use of &lt;code&gt;2&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(77 [2 [1 42] [1 1 153 218]])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with a constant subject and a constant formula, gives the same&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[153 218]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*[77 [2 [1 42] [1 1 153 218]]

20 ::    *[a 2 b c]        *[*[a b] *[a c]]

*[*[77 [1 42]] *[77 [1 1 153 218]]]

19 ::    *[a 1 b]          b

*[42 *[77 [1 1 153 218]]]

*[42 1 153 218]

[153 218]&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#39;lines_2224&#39;&gt;Lines 22-24:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;22 ::    *[a 3 b]          ?*[a b]
23 ::    *[a 4 b]          +*[a b]
24 ::    *[a 5 b]          =*[a b]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In lines 22-24, we meet our axiomatic functions again:&lt;/p&gt;

&lt;p&gt;For instance, if &lt;code&gt;x&lt;/code&gt; is a formula that calculates some product, &lt;code&gt;[4 x]&lt;/code&gt; calculates that product plus one. Hence:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(57 [0 1])
57&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*([132 19] [0 3])
19&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(57 [4 0 1])
58&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*([132 19] [4 0 3])
20&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this seems obvious, you&amp;#8217;re doin&amp;#8217; good. Finally, we jump back up to line 17, the trickiest in the spec:&lt;/p&gt;

&lt;h2 id=&#39;line_17&#39;&gt;Line 17:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;17 ::    *[a [b c] d]      [*[a b c] *[a d]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Um, what?&lt;/p&gt;

&lt;p&gt;Since Nock of an atom just crashes, the practical domain of the Nock function is always a cell. Conventionally, the head of this cell is the &amp;#8220;subject,&amp;#8221; the tail is the &amp;#8220;formula,&amp;#8221; and the result of Nocking it is the &amp;#8220;product.&amp;#8221; Basically, the subject is your data and the formula is your code.&lt;/p&gt;

&lt;p&gt;We could write line 17 less formally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*[subject [formula-x formula-y]]
=&amp;gt;  [*[subject formula-x] *[subject formula-y]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In other words, if you have two Nock formulas &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, a formula that computes the pair of them is just &lt;code&gt;[x y]&lt;/code&gt;. We can recognize this because no atom is a valid formula, and every formula that &lt;em&gt;does not&lt;/em&gt; use line 16 has an atomic head.&lt;/p&gt;

&lt;p&gt;If you know Lisp, you can think of this feature as a sort of &amp;#8220;implicit cons.&amp;#8221; Where in Lisp you would write &lt;code&gt;(cons x y)&lt;/code&gt;, in Nock you write &lt;code&gt;[x y]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(42 [4 0 1])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;42&lt;/code&gt; is the subject (data) and &lt;code&gt;[4 0 1]&lt;/code&gt; is the formula (code), happens to evaluate to &lt;code&gt;43&lt;/code&gt;. Whereas&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(42 [3 0 1])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is &lt;code&gt;1&lt;/code&gt;. So if we evaluate&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(42 [[4 0 1] [3 0 1]])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we get&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[43 1]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Except for the crash defaults (lines 32-35), we&amp;#8217;ve actually completed all the &lt;em&gt;essential&lt;/em&gt; aspects of Nock. The operators up through 5 provide all necessary computational functionality. Nock, though very simple, is actually much more complex than it formally needs to be.&lt;/p&gt;

&lt;p&gt;Operators 6 through 10 are macros. They exist because Nock is not a toy, but a practical interpreter. Let&amp;#8217;s see them all together:&lt;/p&gt;

&lt;h2 id=&#39;lines_2631&#39;&gt;Lines 26-31:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;26 ::    *[a 6 b c d]      *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
27 ::    *[a 7 b c]        *[a 2 b 1 c]
28 ::    *[a 8 b c]        *[a 7 [[7 [0 1] b] 0 1] c]
29 ::    *[a 9 b c]        *[a 7 c [2 [0 1] [0 b]]]
30 ::    *[a 10 [b c] d]   *[a 8 c 7 [0 3] d]
31 ::    *[a 10 b c]]      *[a c]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whoa! Have we entered rocket-science territory? Let&amp;#8217;s try to figure out what these strange formulas do - simplest first. The simplest is clearly line 30:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;31 ::    *[a 10 b c]       *[a c]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;x&lt;/code&gt; is an atom and &lt;code&gt;y&lt;/code&gt; is a formula, the formula &lt;code&gt;[10 x y]&lt;/code&gt; appears to be equivalent to&amp;#8230; &lt;code&gt;y&lt;/code&gt;. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*([132 19] [10 37 [4 0 3]])
20&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why would we want to do this? &lt;code&gt;10&lt;/code&gt; is actually a hint operator. The &lt;code&gt;37&lt;/code&gt; in this example is discarded information - it is not used, formally, in the computation. It may help the interpreter compute the expression more efficiently, however.&lt;/p&gt;

&lt;p&gt;Every Nock computes the same result - but not all at the same speed. What hints are supported? What do they do? Hints are a higher-level convention which do not, and should not, appear in the Nock spec. Some are defined in Hoon. Indeed, a naive Nock interpreter not optimized for Hoon will run Hoon quite poorly. When it gets the product, however, the product will be right.&lt;/p&gt;

&lt;p&gt;There is another reduction for hints - line 30:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;31 ::    *[a 10 [b c] d]   *[a 8 c 7 [0 3] d]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we see what &lt;code&gt;7&lt;/code&gt; and &lt;code&gt;8&lt;/code&gt; do, we&amp;#8217;ll see that this complex hint throws away an arbitrary &lt;code&gt;b&lt;/code&gt;, but computes the formula &lt;code&gt;c&lt;/code&gt; against the subject and&amp;#8230; throws away the product. This formula is simply equivalent to &lt;code&gt;d&lt;/code&gt;. Of course, in practice the product of &lt;code&gt;c&lt;/code&gt; will be put to some sordid and useful use. It could even wind up as a side effect, though we try not to get &lt;em&gt;that&lt;/em&gt; sordid.&lt;/p&gt;

&lt;p&gt;(Why do we even care that &lt;code&gt;c&lt;/code&gt; is computed? Because &lt;code&gt;c&lt;/code&gt; could crash. A correct Nock cannot simply ignore it, and treat both variants of &lt;code&gt;10&lt;/code&gt; as equivalent.)&lt;/p&gt;

&lt;p&gt;We move on to the next simplest operator, &lt;code&gt;7&lt;/code&gt;. Line 26:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	27 ::    *[a 7 b c]        *[a 2 b 1 c]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Suppose we have two formulas, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;. What is the formula &lt;code&gt;[7 b c]&lt;/code&gt;? This example will show you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(42 [7 [4 0 1] [4 0 1]])
44&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;7&lt;/code&gt; is an old mathematical friend, function composition. It&amp;#8217;s easy to see how this is built out of &lt;code&gt;2&lt;/code&gt;. The data to evaluate is simply &lt;code&gt;b&lt;/code&gt;, and the formula is &lt;code&gt;c&lt;/code&gt; quoted.&lt;/p&gt;

&lt;p&gt;Line 28 looks very similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;28 ::    *[a 8 b c]        *[a 7 [[7 [0 1] b] 0 1] c]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Indeed, &lt;code&gt;8&lt;/code&gt; is &lt;code&gt;7&lt;/code&gt;, except that the subject for &lt;code&gt;c&lt;/code&gt; is not simply the product of &lt;code&gt;b&lt;/code&gt;, but the ordered pair of the product of &lt;code&gt;b&lt;/code&gt; and the original subject. Hence:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(42 [8 [4 0 1] [0 1]])
[43 42]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(42 [8 [4 0 1] [4 0 3]])
43&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why would we want to do this? Imagine a higher-level language in which the programmer declares a variable. This language is likely to generate an &lt;code&gt;8&lt;/code&gt;, because the variable is computed against the present subject, and used in a calculation which depends both on the original subject and the new variable.&lt;/p&gt;

&lt;p&gt;For extra credit, explain why we can&amp;#8217;t just define&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*[a 8 b c]        *[a 7 [b 0 1] c]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another simple macro is line 28:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;29 ::    *[a 9 b c]        *[a 7 c [2 [0 1] [0 b]]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;9&lt;/code&gt; is a calling convention. With &lt;code&gt;c&lt;/code&gt;, we produce a noun which contains both code and data - a &lt;em&gt;core&lt;/em&gt;. We use this core as the subject, and apply the formula within it at slot &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And finally, we come to the piece de resistance - line 26:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;26 ::    *[a 6 b c d]      *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great giblets! WTF is this doing? It seems we&amp;#8217;ve finally arrived at some real rocket science.&lt;/p&gt;

&lt;p&gt;Actually, &lt;code&gt;6&lt;/code&gt; is a primitive known to every programmer - good old &amp;#8220;if.&amp;#8221; If &lt;code&gt;b&lt;/code&gt; evaluates to &lt;code&gt;0&lt;/code&gt;, we produce &lt;code&gt;c&lt;/code&gt;; if &lt;code&gt;b&lt;/code&gt; evaluates to &lt;code&gt;1&lt;/code&gt;, we produce &lt;code&gt;d&lt;/code&gt;; otherwise, we crash.&lt;/p&gt;

&lt;p&gt;For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(42 [6 [1 0] [4 0 1] [1 233]])
43&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(42 [6 [1 1] [4 0 1] [1 233]])
233&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In real life, of course, the Nock implementor knows that &lt;code&gt;6&lt;/code&gt; is &amp;#8220;if&amp;#8221; and implements it as such. There is no practical sense in reducing through this macro, or any of the others. We could have defined &amp;#8220;if&amp;#8221; as a built-in function, like increment - except that we can write &amp;#8220;if&amp;#8221; as a macro. If a funky macro.&lt;/p&gt;

&lt;p&gt;It&amp;#8217;s a good exercise, however, to peek inside the funk.&lt;/p&gt;

&lt;p&gt;We can actually simplify the semantics of &lt;code&gt;6&lt;/code&gt;, at the expense of breaking the system a little, by creating a macro that works as &amp;#8220;if&amp;#8221; only if &lt;code&gt;b&lt;/code&gt; is a proper boolean and produces &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. Perhaps we have a higher-level type system which checks this.&lt;/p&gt;

&lt;p&gt;This simpler &amp;#8220;if&amp;#8221; would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*[a 6 b c d]    *[a [2 [0 1] [2 [1 c d] [[1 0] [4 4 b]]]]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or without so many unnecessary brackets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*[a 6 b c d]    *[a 2 [0 1] 2 [1 c d] [1 0] [4 4 b]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How does this work? We&amp;#8217;ve replaced &lt;code&gt;[6 b c d]&lt;/code&gt; with the formula &lt;code&gt;[2 [0 1] [2 [1 c d] [[1 0] [4 4 b]]]]&lt;/code&gt;. We see two uses of &lt;code&gt;2&lt;/code&gt;, our evaluation operator - an outer and an inner.&lt;/p&gt;

&lt;p&gt;Call the inner one &lt;code&gt;i&lt;/code&gt;. So we have &lt;code&gt;[2 [0 1] i]&lt;/code&gt;. Which means that, to calculate our product, we use &lt;code&gt;[0 1]&lt;/code&gt; - that is, the original subject - as the subject; and the product of &lt;code&gt;i&lt;/code&gt; as the formula.&lt;/p&gt;

&lt;p&gt;Okay, cool. So &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;[2 [1 c d] [[1 0] [4 4 b]]]&lt;/code&gt;. We compute Nock with subject &lt;code&gt;[1 c d]&lt;/code&gt;, formula &lt;code&gt;[[1 0] [4 4 b]]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Obviously, &lt;code&gt;[1 c d]&lt;/code&gt; produces just &lt;code&gt;[c d]&lt;/code&gt; - that is, the ordered pair of the &amp;#8220;then&amp;#8221; and &amp;#8220;else&amp;#8221; formulas. &lt;code&gt;[[1 0] [4 4 b]]&lt;/code&gt; is a line 23 cell - its head is &lt;code&gt;[1 0]&lt;/code&gt;, producing just &lt;code&gt;0&lt;/code&gt;, its tail &lt;code&gt;[4 4 b]&lt;/code&gt;, producing&amp;#8230; what? Well, if &lt;code&gt;[4 b]&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt; plus &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;[4 4 b]&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt; plus &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;#8217;re assuming that &lt;code&gt;b&lt;/code&gt; produces either &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. So &lt;code&gt;[4 4 b]&lt;/code&gt; yields either &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;. &lt;code&gt;[[1 0] [4 4 b]]&lt;/code&gt; is either &lt;code&gt;[0 2]&lt;/code&gt; or &lt;code&gt;[0 3]&lt;/code&gt;. Applied to the subject &lt;code&gt;[c d]&lt;/code&gt;, this gives us either &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; - the product of our inner evaluation &lt;code&gt;i&lt;/code&gt;. This is applied to the original subject, and the result is &amp;#8220;if.&amp;#8221;&lt;/p&gt;

&lt;p&gt;But we need the full power of the funk, because if &lt;code&gt;b&lt;/code&gt; produces, say, &lt;code&gt;7&lt;/code&gt;, all kinds of weirdness will result. We&amp;#8217;d really like &lt;code&gt;6&lt;/code&gt; to just crash if the test product is not a boolean. How can we accomplish this? This is an excellent way to prove to yourself that you understand Nock: figure out what the real &lt;code&gt;6&lt;/code&gt; does. Or you could just agree that &lt;code&gt;6&lt;/code&gt; is &amp;#8220;if,&amp;#8221; and move on.&lt;/p&gt;

&lt;p&gt;(It&amp;#8217;s worth noting that in practical, compiler-generated Nock, we never do anything as funky as these &lt;code&gt;6&lt;/code&gt; macro internals. There&amp;#8217;s no reason we couldn&amp;#8217;t build formulas at runtime, but we have no reason to and we don&amp;#8217;t - except when actually metaprogramming. As in most languages, normally code is code and data is data.)&lt;/p&gt;

&lt;h1 id=&#39;14_decrement_in_nock&#39;&gt;1.4 Decrement in Nock&lt;/h1&gt;

&lt;p&gt;A good practice exercise for Nock is a decrement formula. Ie, a formula &lt;code&gt;f&lt;/code&gt; which implements the partial function that produces &lt;code&gt;(s - 1)&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is a nonzero atom, and otherwise does not terminate.&lt;/p&gt;

&lt;p&gt;The normal Hoon programmer has written one Nock formula: this one. Since decrement uses all the Nock techniques the Hoon compiler uses, the exercise is a good foundation. After you write decrement (or just follow this example), you&amp;#8217;ll never need to deal with Nock again.&lt;/p&gt;

&lt;p&gt;As we know, the equivalent formula for increment is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[4 0 1]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~&amp;gt;tasfyn-partyv .*(42 [4 0 1])
43&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, increment is built into Nock. So, ha, that&amp;#8217;s easy.&lt;/p&gt;

&lt;p&gt;How do we decrement? A good way to start is to gaze fondly on how we&amp;#8217;d do it if we actually had a real language, ie, Hoon. Here is a minimal decrement in Hoon:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=&amp;gt;  a=.                     ::  line 1
=+  b=0                     ::  line 2
|-                          ::  line 3
?:  =(a +(b))               ::  line 4
  b                         ::  line 5
$(b +(b))                   ::  line 6&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or for fun, on one line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=&amp;gt;(a=. =+(b=0 |-(?:(=(a +(b)) b $(b +(b))))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does Hoon actually work?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt;  =&amp;gt;(42 =&amp;gt;(a=. =+(b=0 |-(?:(=(a +(b)) b $(b +(b)))))))
41&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#8217;s translate this into English. How do we decrement the subject? First (line 1), we rename the subject &lt;code&gt;a&lt;/code&gt;. Second (line 2), we add a variable, &lt;code&gt;b&lt;/code&gt;, an atom with value &lt;code&gt;0&lt;/code&gt;. Third (line 3), we loop. Fourth, we test if &lt;code&gt;a&lt;/code&gt; equals &lt;code&gt;b&lt;/code&gt; plus 1 (line 4), produce &lt;code&gt;b&lt;/code&gt; if it does (line 5), repeat the loop with &lt;code&gt;b&lt;/code&gt; set to &lt;code&gt;b&lt;/code&gt; plus 1 (line 6) if it doesn&amp;#8217;t. Obviously, while the syntax is unusual, the algorithm is anything but deep. We are calculating &lt;code&gt;b&lt;/code&gt; minus one by counting up from &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(Obviously, this is an O(n) algorithm. Is there a better way? There is not. Do we actually do this in practice? Yes and no.)&lt;/p&gt;

&lt;p&gt;Unfortunately we are missing a third of our Rosetta stone. We have decrement in Hoon and we have it in English. How do we express this in Nock? What will the Hoon compiler generate from the code above? Let&amp;#8217;s work through it line by line.&lt;/p&gt;

&lt;p&gt;Nock has no types, variable names, etc. So line 1 is a no-op.&lt;/p&gt;

&lt;p&gt;How do we add a variable (line 2)? We compute a new subject, which is a cell of the present subject and the variable. With this new subject, we execute another formula.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;0&lt;/code&gt; is a constant, a formula that produces it is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1 0]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To combine &lt;code&gt;0&lt;/code&gt; with the subject, we compute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[1 0] [0 1]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which, if our subject is 42, gives us&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[0 42]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which we can use as the subject for an inner formula, &lt;code&gt;g&lt;/code&gt;. Composing our new variable with &lt;code&gt;g&lt;/code&gt;, we have &lt;code&gt;f&lt;/code&gt; as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[2 [[1 0] [0 1]] [1 g]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which seems a little funky for something so simple. But we can simplify it with the composition macro, &lt;code&gt;7&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[7 [[1 0] [0 1]] g]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and still further with the augmentation macro, &lt;code&gt;8&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 [1 0] g]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you refer back to the Nock definition, you&amp;#8217;ll see that all these formulas are semantically equivalent.&lt;/p&gt;

&lt;p&gt;Let&amp;#8217;s continue with our decrement. So what&amp;#8217;s &lt;code&gt;g&lt;/code&gt;? We seem to loop. Does Nock have a loop operator? It most certainly does not. So what do we do?&lt;/p&gt;

&lt;p&gt;We build a noun called a &lt;em&gt;core&lt;/em&gt; - a construct which is behind any kind of interesting control flow in Hoon. Of course, the Nock programmer is not constrained to use the same techniques as the Hoon compiler, but it is probably a good idea.&lt;/p&gt;

&lt;p&gt;In Hoon, all the flow structures from your old life as an Earth programmer become cores. Functions and/or closures are cores, objects are cores modules are cores, even loops are cores.&lt;/p&gt;

&lt;p&gt;The core is just a cell whose tail is data (possibly containing other cores) and whose head is code (containing one or more formulas). The tail is the &lt;em&gt;payload&lt;/em&gt; and the head is the &lt;em&gt;battery&lt;/em&gt;. Hence your core is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[bat pay]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To activate a core, pick a formula out of the battery, and use the entire core (_not_ just the payload) as the subject.&lt;/p&gt;

&lt;p&gt;(A core formula is called an &lt;em&gt;arm&lt;/em&gt;. An arm is almost like an object-oriented method, but not quite - a method would be an arm that produces a function on an argument. The arm is just a function of the core, ie, a computed attribute.)&lt;/p&gt;

&lt;p&gt;Of course, because we feed it the entire core, our arm can invoke itself (or any other formula in the battery). Hence, it can loop. And this is what a loop is - the simplest of cores.&lt;/p&gt;

&lt;p&gt;We need to do two things with this core: create it, and activate it. To be precise, we need two formulas: a formula which produces the core, and one which activates its subject. We can compose these functions with the handy &lt;code&gt;7&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 [1 0] [7 p a]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;p&lt;/code&gt; produces our core, &lt;code&gt;a&lt;/code&gt; activates it. Let&amp;#8217;s take these in reverse order. How do we activate a core?&lt;/p&gt;

&lt;p&gt;Since we have only one formula, it&amp;#8217;s is the battery itself. Thus we want to execute Nock with the whole core (already the subject, and the entire battery (slot &lt;code&gt;2&lt;/code&gt;). Hence, &lt;code&gt;a&lt;/code&gt; is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[2 [0 1] [0 2]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could also use the handy &lt;code&gt;9&lt;/code&gt; macro - which almost seems designed for firing arms on cores:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[9 2 [0 1]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which leaves us seeking&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 [1 0] [7 p [9 2 0 1]]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And all we have to do is build the core, &lt;code&gt;p&lt;/code&gt;. How do we build a core? We add code to the subject, just as we added a variable above. The initial value of our counter was a constant, &lt;code&gt;0&lt;/code&gt;. The initial (and permanent) value of our battery is a constant, the loop formula &lt;code&gt;l&lt;/code&gt;. So &lt;code&gt;p&lt;/code&gt; is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 [1 l] [0 1]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which would leave us seeking&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 [1 0] [7 [8 [1 l] [0 1]] [9 2 0 1]]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;except that we have duplicated the &lt;code&gt;8&lt;/code&gt; pattern again, since we know&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[7 [8 [1 l] [0 1]] [9 2 0 1]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 [1 l] [9 2 0 1]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so the full value of &lt;code&gt;f&lt;/code&gt; is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 [1 0] [8 [1 l] [9 2 0 1]]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus our only formula to compose is the loop body, &lt;code&gt;l&lt;/code&gt;. Its subject is the loop core:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[bat pay]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;bat&lt;/code&gt; is just the loop formula, and &lt;code&gt;pay&lt;/code&gt; is the pair &lt;code&gt;[a
b]&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; being the input subject, and &lt;code&gt;b&lt;/code&gt; the counter. Thus we could also write this subject as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[l b a]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we see readily that &lt;code&gt;a&lt;/code&gt; is at slot &lt;code&gt;7&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; &lt;code&gt;6&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; &lt;code&gt;2&lt;/code&gt;. With this subject, we need to express the Hoon loop body&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?:  =(a +(b))               ::  line 4
  b                         ::  line 5
$(b +(b))                   ::  line 6&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is obviously an if statement, and it calls for &lt;code&gt;6&lt;/code&gt;. Ie:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[6 t y n]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Giving our decrement program as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 [1 0] [8 [1 6 t y n] [9 2 0 1]]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For &lt;code&gt;t&lt;/code&gt;, how do we compute a flag that is yes (&lt;code&gt;0&lt;/code&gt;) if &lt;code&gt;a&lt;/code&gt; equals &lt;code&gt;b&lt;/code&gt; plus one? Equals, we recall, is &lt;code&gt;5&lt;/code&gt;. So &lt;code&gt;t&lt;/code&gt; can only be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[5 [0 7] [4 0 6]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If so, our product &lt;code&gt;y&lt;/code&gt; is just the counter &lt;code&gt;b&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[0 6]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if not? We have to re-execute the loop with the counter incremented. If we were executing it with the same counter, obviously an infinite loop, we could use the same core:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[9 2 0 1]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But instead we need to construct a new core with the counter incremented:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[l +(b) a]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ie,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[0 2] [4 0 6] [0 7]] &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;n&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[9 2 [[0 2] [4 0 6] [0 7]]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hence our complete decrement. Let&amp;#8217;s reformat vertically so we can actually read it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; [8 
   [1 0] 
   [ 8 
     [ 1 
       [ 6 
         t 
         y 
         n
       ]
     ]
     [9 2 0 1]
   ]
 ]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which becomes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [8 
    [1 0] 
    [ 8 
      [ 1 
        [ 6 
          [5 [0 7] [4 0 6]]
          [0 6]
          [9 2 [[0 2] [4 0 6] [0 7]]]
        ]
      ]
      [9 2 0 1]
    ]
  ]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or, on one line without superfluous brackets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 [1 0] 8 [1 6 [5 [0 7] 4 0 6] [0 6] 9 2 [0 2] [4 0 6] 0 7] 9 2 0 1]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which works for the important special case, 42:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; .*(42 [8 [1 0] 8 [1 6 [5 [0 7] 4 0 6] [0 6] 9 2 [0 2] [4 0 6] 0 7] 9 2 0 1])
41&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you understood this, you understand Nock. At least in principle!&lt;/p&gt;

&lt;p&gt;If you want to play around more with Nock, the command line will start getting unwieldy. Fortunately, the standard install contains the above Nock decrement packaged as an Arvo app, which you can edit and change if you&amp;#8217;d like to get ambitious. Just run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; :toy/ndec 19
18&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The file driving this is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hub/$seat/toy/app/ndec.holw&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit this file, ignoring everything above the Nock formula, and hit return in the console to see it update:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~tasfyn-partyv&amp;gt; 
: ~tasfyn-partyv/toy/app/ndec/holw/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If decrement seems fun - why not write add? I wrote a Nock adder a long, long time ago. But I&amp;#8217;ve forgotten where I put it. There is absolutely no use in this exercise, except to prove to yourself that you&amp;#8217;ve mastered Nock.&lt;/p&gt;

&lt;h1 id=&#39;appendix_a_operator_reductions&#39;&gt;Appendix A: Operator Reductions&lt;/h1&gt;

&lt;h2 id=&#39;_reduction&#39;&gt;&lt;code&gt;6&lt;/code&gt; Reduction:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;26 ::    *[a 6 b c d]      *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]

*[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]

21 ::    *[a 2 b c]        *[*[a b] *[a c]]

*[*[a 0 1] *[a 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]]

19 ::    *[a 0 b]          /[b a]

*[a *[a 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]]

21 ::    *[a 2 b c]        *[*[a b] *[a c]]

*[a *[*[a [1 c d]] *[a [1 0] 2 [1 2 3] [1 0] 4 4 b]]]

20 ::    *[a 1 b]          b

17 ::    *[a [b c] d]      [*[a b c] *[a d]]

*[a *[[c d] [*[a 1 0] *[a 2 [1 2 3] [1 0] 4 4 b]]]]

20 ::    *[a 1 b]          b

*[a *[[c d] [0 *[a 2 [1 2 3] [1 0] 4 4 b]]]]

21 ::    *[a 2 b c]        *[*[a b] *[a c]]

*[a *[[c d] [0 *[*[a [1 2 3]] *[a [1 0] 4 4 b]]]]]

20 ::    *[a 1 b]          b

*[a *[[c d] [0 *[[2 3] *[a [1 0] 4 4 b]]]]]

17 ::    *[a [b c] d]      [*[a b c] *[a d]]

*[a *[[c d] [0 *[[2 3] [*[a [1 0]] *[a 4 4 b]]]]]]

20 ::    *[a 1 b]          b

*[a *[[c d] [0 *[[2 3] [0 *[a 4 4 b]]]]]]

23 ::    *[a 4 b]          +*[a b]

*[a *[[c d] [0 *[[2 3] [0 ++[a b]]]]]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;6&lt;/code&gt; Reduced:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;6r ::   *[a 6 b c d]               *[a *[[c d] [0 *[[2 3] [0 ++[a b]]]]]]&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#39;_reduction&#39;&gt;&lt;code&gt;7&lt;/code&gt; Reduction:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;27 ::    *[a 7 b c]        *[a 2 b 1 c]

*[a 2 b 1 c]

21 ::    *[a 2 b c]        *[*[a b] *[a c]] 

*[*[a b] *[a 1 c]]

20:    *[a 1 b]          b
 
*[*[a b] c]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;7&lt;/code&gt; Reduced:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;7r ::     *[a 7 b c]         *[*[a b] c]&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#39;_reduction&#39;&gt;&lt;code&gt;8&lt;/code&gt; Reduction:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;28 ::    *[a 8 b c]        *[a 7 [[7 [0 1] b] 0 1] c]

*[a 7 [[7 [0 1] b] 0 1] c]   

7r ::     *[a 7 b c]         *[*[a b] c]

*[*[a [7 [0 1] b] 0 1]] c]

17 ::    *[a [b c] d]      [*[a b c] *[a d]]

*[[*[a [7 [0 1] b]] *[a 0 1]] c]

19 ::    *[a 0 b]          /[b a]

*[[*[a [7 [0 1] b]] /[1 a]] c]

11 ::    /[1 a]            a

*[[*[a [7 [0 1] b]] a] c]

7r ::     *[a 7 b c]         *[*[a b] c]

*[[*[*[a 0 1]] b] a] c]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;8&lt;/code&gt; Reduced:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;8r ::     *[a 8 b c]        *[[*[a b] a] c]&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#39;_reduction&#39;&gt;&lt;code&gt;9&lt;/code&gt; Reduction:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;29 :: *[a 9 b c]        *[a 7 c [2 [0 1] [0 b]]]

*[a 7 c [2 [0 1] [0 b]]]

7r ::     *[a 7 b c]         *[*[a b] c]

*[*[a c] [2 [0 1] [0 b]]]

21 ::     *[a 2 b c]        *[*[a b] *[a c]]

*[*[*[a c] [0 1]] *[*[a c] [0 b]]]

19 ::     *[a 0 b]          /[b a]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;9&lt;/code&gt; Reduced:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;9r ::     *[a 9 b c]        *[*[a c] *[*[a c] 0 b]] &lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#39;_reduction&#39;&gt;&lt;code&gt;10&lt;/code&gt; Reduction:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;*[a 10 [b c] d]   *[a 8 c 7 [0 2] d]

8r ::     *[a 8 b c]        [[*[a b] a] c]

*[[*[a c] a] 7 [0 2] d]

7r ::     *[a 7 b c]        *[*[a b] c]

*[*[[*[a c] a] 0 3] d]

19 ::     *[a 0 b]          /[b a]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;10&lt;/code&gt; reduced:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10r ::    *[a 10 [b c] d]   *[a d]&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>Chapter 1 &#58; Crash course in Arvo</title>
   <link href="http://urbit.org/2013/08/22/Chapter-1-arvo.html"/>
   <updated>2013-08-22T00:00:00-04:00</updated>
   <id>http://urbit.org/2013/08/22/Chapter-1-arvo</id>
   <content type="html">&lt;p&gt;Welcome to Urbit!&lt;/p&gt;

&lt;h1 id=&#39;10_yo_this_is_unfinished_shit&#39;&gt;1.0 YO THIS IS UNFINISHED SHIT!&lt;/h1&gt;

&lt;p&gt;All of the doc herein is cheerfully certified as incorrect, incomplete, misleading and almost certainly misguided. Do not use! Please return to your NSA-certified digital plantation. If you found this site by accident, please keep it to yourself. Clear your hard drive, wipe your search history&amp;#8230; but always trust content from Tlon, Tianming, Urban Republic.&lt;/p&gt;

&lt;h1 id=&#39;11_build&#39;&gt;1.1 Build&lt;/h1&gt;

&lt;p&gt;First, build&amp;#8230;&lt;/p&gt;

&lt;h3 id=&#39;prepare_your_computer&#39;&gt;Prepare your computer:&lt;/h3&gt;

&lt;p&gt;Urbit depends on:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gmp&lt;/li&gt;

&lt;li&gt;libsigsegv&lt;/li&gt;

&lt;li&gt;openssl&lt;/li&gt;

&lt;li&gt;libssl-dev (Linux only)&lt;/li&gt;

&lt;li&gt;ncurses (Linux only)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Currently we support OSX, Ubuntu and AWS Linux AMI. Intrepid ninjas may attempt ports to other OSes. If you&amp;#8217;re not an intrepid ninja, try a VM (eg, VirtualBox).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OS X:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Do you have XCode? Type &lt;code&gt;gcc&lt;/code&gt;. If it says &lt;code&gt;no input files&lt;/code&gt;, you have XCode.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Otherwise, install XCode: &lt;code&gt;https://developer.apple.com/xcode/&lt;/code&gt;, with the Command Line tools.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Do you have Homebrew? Type &lt;code&gt;brew&lt;/code&gt;. If it does something, you have Homebrew.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Otherwise, &lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&amp;quot;&lt;/code&gt; will install it. (Can you use MacPorts? Yes you can. You can also resolve the dependencies by hand :-)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sudo brew install gmp libsigsegv openssl&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This will ask you for the root password, which ideally you know.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ubuntu:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get install libgmp3-dev libsigsegv-dev openssl libssl-dev libncurses5-dev&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;AWS:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sudo yum --enablerepo epel install gcc git gmp-devel openssl-devel ncurses-devel libsigsegv-devel&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#39;get_the_source&#39;&gt;Get the source:&lt;/h3&gt;

&lt;p&gt;Either:&lt;/p&gt;

&lt;p&gt;A. Download and unzip &lt;code&gt;https://github.com/urbit/urbit/archive/master.zip&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;B. &lt;code&gt;git clone https://github.com/urbit/urbit.git&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#39;configure_your_build&#39;&gt;Configure your build:&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cd&lt;/code&gt; to the unpacked Urbit directory you just created. If this works, &lt;code&gt;ls urb&lt;/code&gt; should show:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;urbit.pill  zod/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! Now, let&amp;#8217;s do some dirty Unix stuff to set up your environment. If you know what this is doing, feel free to do it right. Otherwise:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;export URBIT_HOME=`pwd`/urb&amp;quot; &amp;gt;&amp;gt;~/.bash_profile
source ~/.bash_profile&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make sure this worked,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $URBIT_HOME&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;should show &lt;code&gt;/urb&lt;/code&gt; within the current directory.&lt;/p&gt;

&lt;h3 id=&#39;make&#39;&gt;make:&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt;. Sometimes things are just easy.&lt;/p&gt;

&lt;h3 id=&#39;vere&#39;&gt;vere:&lt;/h3&gt;

&lt;p&gt;Run &lt;code&gt;bin/vere -c mypier&lt;/code&gt;, where &lt;code&gt;mypier&lt;/code&gt; is a directory that doesn&amp;#8217;t yet exist. All your state (an append-only log and a memory checkpoint) will live in this directory. Its name doesn&amp;#8217;t matter and is not visible internally.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;pier&lt;/em&gt; is an Urbit virtual machine that hosts one or more Urbit identities, or &lt;em&gt;ships&lt;/em&gt;. When you run &lt;code&gt;vere -c&lt;/code&gt;, it automatically creates a 128-bit ship, or &lt;code&gt;submarine&lt;/code&gt;. Your name (a hash of a randomly-generated public key) will look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~machec-binnev-dordeb-sogduc--dosmul-sarrum-faplec-nidted&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First you&amp;#8217;ll see a string of messages like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vere: urbit home is /Users/cyarvin/Documents/src/u3/urb
loom: mapped 1024MB
time: ~2013.9.1..03.57.11..4935
ames: on localhost, UDP 63908.
generating 2048-bit RSA pair...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then it&amp;#8217;ll pause a little, &amp;#8216;cause this is slow&amp;#8230; and then&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;saving passcode in /Users/cyarvin/.urbit/~magsut-hopful.txt
(for real security, write it down and delete the file...)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and, then, if the network gods are happy, your submarine will start pulling down Arvo files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; + /~machec-binnev-dordeb-sogduc--dosmul-sarrum-faplec-nidted/main/1/bin/ticket/hoon
 + /~machec-binnev-dordeb-sogduc--dosmul-sarrum-faplec-nidted/main/1/bin/reset/hoon
 + /~machec-binnev-dordeb-sogduc--dosmul-sarrum-faplec-nidted/main/1/bin/ye/hoon
 + /~machec-binnev-dordeb-sogduc--dosmul-sarrum-faplec-nidted/main/1/bin/ls/hoon&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the like. You&amp;#8217;ll see a couple pages of this stuff. Don&amp;#8217;t worry too much about the details right now. Finally, you&amp;#8217;ll get the Arvo shell prompt (which is also a Hoon REPL):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~machec-binnev-dordeb-sogduc--dosmul-sarrum-faplec-nidted/try=&amp;gt; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, you need to decide whether a mere submarine is enough for you right now. This monicker is a mouthful. You can stick with it (for now), but&amp;#8230; you&amp;#8217;re going to need a wider xterm.&lt;/p&gt;

&lt;p&gt;Which might be fine! However, please note that just by sending a simple email, you can get a much better ship - a &lt;code&gt;destroyer&lt;/code&gt;, with a nice short name like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just email &lt;code&gt;urbit@urbit.org&lt;/code&gt;, with your submarine in the subject. We&amp;#8217;ll send you destroyers - not one, but &lt;em&gt;two&lt;/em&gt;. Yes, two! Tell us something cool in the body, and we&amp;#8217;ll send you even more.&lt;/p&gt;

&lt;p&gt;If you have a destroyer, you need to configure it. Otherwise, just stretch that xterm wide and skip to section 1.2.&lt;/p&gt;

&lt;p&gt;Your destroyers will arrive in the form of &lt;span&gt;ship ticket&lt;/span&gt; pairs. Let&amp;#8217;s say one of your ships is &lt;code&gt;~waclux-tomwyc&lt;/code&gt; and its ticket is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ribdyr-famtem-larrun-figtyd&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(What are these strings, anyway? Just random unsigned integers, rendered in Hoon&amp;#8217;s syllabic base, &lt;code&gt;@p&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;A new life awaits you on the off-world colonies! To begin, just type at the prompt:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:begin ~waclux-tomwyc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and follow the directions. When the script completes, hit return and you&amp;#8217;ll be the &lt;code&gt;~waclux-tomwyc&lt;/code&gt; you wanted to be.&lt;/p&gt;

&lt;h1 id=&#39;12_taming_arvo&#39;&gt;1.2 Taming Arvo&lt;/h1&gt;

&lt;p&gt;If all went well, you now have a nice short prompt:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If all did not go well (send us another email), or you&amp;#8217;re just too impatient to wait for your destroyer, you have a big long prompt. Which is fine, really, just ugly - and all these exercises will still work.&lt;/p&gt;

&lt;p&gt;Let&amp;#8217;s try a few quick things to stretch your fingers. Type these command lines and you should see the matching results:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; &amp;quot;hello, world&amp;quot;
&amp;quot;hello, world&amp;quot;

~waclux-tomwyc/try=&amp;gt; (add 2 2)
4

~waclux-tomwyc/try=&amp;gt; :hello %world
&amp;quot;hello, world.&amp;quot;

~waclux-tomwyc/try=&amp;gt; :cat /=main=/bin/hello/hoon
::
::  /=main=/bin/hello/hoon
::
|=  *
|=  [planet=@ta ~]
^-  bowl
:_  ~  :_  ~
:-  %%
!&amp;gt;(&amp;quot;hello, {(trip planet)}.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What did you just do?&lt;/p&gt;

&lt;p&gt;One, you used Arvo as a Hoon REPL to print the constant &lt;code&gt;&amp;quot;hello, world&amp;quot;&lt;/code&gt;, which is a fancy way to write the Nock noun&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[104 101 108 108 111 44 32 119 111 114 108 100 0]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two, you called the Hoon &lt;code&gt;add&lt;/code&gt; function to see that two plus two is four. Math seems to work the same on the off-world colonies.&lt;/p&gt;

&lt;p&gt;Three, you ran the Arvo application &lt;code&gt;:hello&lt;/code&gt; with the argument &lt;code&gt;%world&lt;/code&gt;, which is just a fancy way to write the atom &lt;code&gt;431.316.168.567&lt;/code&gt; (or, for non-Germans, &lt;code&gt;431,316,168,567&lt;/code&gt;). You might recognize it better as &lt;code&gt;0x64.6c72.6f77&lt;/code&gt; - the ASCII characters in LSB first order.&lt;/p&gt;

&lt;p&gt;(Is Urbit German? Sadly, no. But all our noun print formats are URL-safe, which dot is and comma isn&amp;#8217;t.)&lt;/p&gt;

&lt;p&gt;And you (4) used the Arvo application :cat to print the Hoon file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/=main=/bin/hello/hoon&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which, supposing your current date is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~2013.9.1..04.38.31..f259&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(ie, September 1, 2013 at 4:38:31 GMT/LS25 plus 0xf259/65536 seconds), is equivalent to the global path&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/~waclux-tomwyc/main/~2013.8.23..04.38.31..f259/bin/hello/hoon&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which anyone in Urbit can, see and even use - but we&amp;#8217;re getting ahead of ourselves.&lt;/p&gt;

&lt;p&gt;In any case, what we&amp;#8217;ve seen is that Arvo is a dangerous and powerful operating system which if handled improperly can cause serious injury or loss of life. We exaggerate. Slightly.&lt;/p&gt;

&lt;p&gt;The first thing you need to know is how to control this tool. Try your arrow keys - you&amp;#8217;ll see that Arvo has traditional Unix history editing. Up and down, left and right work, as do the simple emacs controls:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^A  go to beginning of line
^B  left arrow
^D  delete next character
^E  go to end of line
^F  right arrow
^K  kill to end of line
^L  clear the screen
^U  kill the whole line
^Y  yank (restore from kill ring)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;#8217;t expect any other emacs (or even readline - this is not readline, it&amp;#8217;s internal to Arvo) commands to work.&lt;/p&gt;

&lt;p&gt;There are also some special control keys specific to Arvo. It&amp;#8217;s a good idea to learn these first so that you feel in, um, control.&lt;/p&gt;

&lt;p&gt;First, we&amp;#8217;ll quit out of an infinite loop with ^C:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :infinite&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you hit return at the end of this line, Arvo will appear to hang. Do not be alarmed! This is not a bug - it means that we&amp;#8217;ve started running our infinite loop before printing the next console prompt. Simply hit ^C, and you&amp;#8217;ll see&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;! intr
~waclux-tomwyc/try=&amp;gt; :infinite&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hit ^U to delete the line and escape from infinity. Arvo is a deterministic OS; you interrupted it while processing an event that would never terminate. It returns to the state it was in before you hit return - as if nothing had ever happened.&lt;/p&gt;

&lt;p&gt;You&amp;#8217;re probably used to using nondeterministic, preemptive OSes, in which the difference between a waiting process and an executing event isn&amp;#8217;t apparent to the user. Since Arvo is not preemptive, it has two very different states: waiting and working.&lt;/p&gt;

&lt;p&gt;When Arvo is working, ^C cancels the event it&amp;#8217;s working on. When Arvo is waiting, ^C ends the current task, which is the task that&amp;#8217;s currently prompting you - or showing the &lt;code&gt;[waiting...]&lt;/code&gt; prompt, indicating that it&amp;#8217;s waiting for something else other than keyboard input.&lt;/p&gt;

&lt;p&gt;Try this by running&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :begin

Do you have a ship and a ticket? yes&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then hit ^C and you&amp;#8217;ll be back to the command prompt (which, unlike in Unix, is not a task itself, but part of the OS).&lt;/p&gt;

&lt;p&gt;We don&amp;#8217;t always want to kill the prompting task. We often want to switch between tasks, or between tasks and the command line. Sort of like switching between windows, except in a command line. We do this with ^X. Try&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :begin

Do you have a ship and a ticket? yes&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But hit ^X instead of ^C. You&amp;#8217;ll get a prompt again. Use it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :begin

~waclux-tomwyc/try=&amp;gt; :hello %world
&amp;quot;hello, world.&amp;quot;
~waclux-tomwyc/try=&amp;gt; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hit ^X again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :begin

~waclux-tomwyc/try=&amp;gt; :hello %world
&amp;quot;hello, world.&amp;quot;
Do you have a ship and a ticket? yes&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, hit ^C to kill the task.&lt;/p&gt;

&lt;p&gt;There&amp;#8217;s one more magic control key that switches your whole reality. This is ^W, which switches between the ships in a pier. Do you have multiple ships in your pier? Sure - you still have your old submarine. Hit ^W:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~machec-binnev-dordeb-sogduc--dosmul-sarrum-faplec-nidted/try=&amp;gt; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hit ^W again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, Arvo is a single-level store. Since it&amp;#8217;s not the &amp;#8217;70s anymore and disk is cheap, everything you do is saved for ever. (In fact, it&amp;#8217;s saved in two ways - as a memory image and an event log - so you, or the government if they haz your filez, can repeat every computation you&amp;#8217;ve every performed.)&lt;/p&gt;

&lt;p&gt;As in Unix, hitting ^D on an empty line ends the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; 
oxford:~/urbit; pwd
/Users/cyarvin/urbit
oxford:~/urbit; echo &amp;quot;hello, world&amp;quot;
hello, world
oxford:~/urbit; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can restart and be right back where you were - just run &lt;code&gt;vere&lt;/code&gt; without &lt;code&gt;-c&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;oxford:~/urbit; bin/vere mypier
vere: urbit home is /Users/cyarvin/urb
loom: loaded 9MB
time: ~2013.9.1..17.23.05..0cc1
ames: on localhost, UDP 60342.
http: live on 8080
rest: checkpoint to event 383
rest: old 0v1c.gkr1o, new 0v10.m4gdu
---------------- playback complete----------------
waclux-tomwyc/try=&amp;gt; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use your arrow keys and you&amp;#8217;ll see your history is still there. Arvo is indestructible and can be shut down however you like without losing data. Also, starting a new process while an old one is still running will kill the old one safely. And, to leave a server running in the background, use &lt;code&gt;vere -d&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But don&amp;#8217;t try to operate the same ship on two Unix hosts at the same time. This will confuse everyone, including yourself.&lt;/p&gt;

&lt;h1 id=&#39;13_path_magic&#39;&gt;1.3 Path magic&lt;/h1&gt;

&lt;p&gt;What do we know? Okay, so this is an OS. It&amp;#8217;s a little like Unix but different. It can print expressions and run commands. Commands start with a colon. Let&amp;#8217;s try the simplest command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :ls
! type-fail
! exit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hey, that didn&amp;#8217;t work! It didn&amp;#8217;t work for two reasons. One, Arvo command-line arguments are typed, and &lt;code&gt;:ls&lt;/code&gt; expects a path. Two, &lt;code&gt;:ls&lt;/code&gt; needs that path - unlike in Unix, applications can&amp;#8217;t see the current path or shell variables. (This is because Arvo doesn&amp;#8217;t have 57 different ways of configuring an app.) So try&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :ls /~waclux-tomwyc/try=
con bin lib doc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This seems somewhat cumbersome - isn&amp;#8217;t there a way to refer to the current path? There is, though it doesn&amp;#8217;t look like Unix.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :ls %
con bin lib doc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#8217;s look at these paths in a little more detail. An Arvo path is more or less the same thing as a Unix path, except that Unix isn&amp;#8217;t a global revision-control store. It has the general form&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/ship/desk/case/spur&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;ship&lt;/code&gt; is your ship, &lt;code&gt;desk&lt;/code&gt; is a project (repository, branch, etc), &lt;code&gt;case&lt;/code&gt; is a revision of that project (a change number, a date or a label), and &lt;code&gt;spur&lt;/code&gt; is a path within it.&lt;/p&gt;

&lt;p&gt;As in Unix, the shell (&lt;code&gt;batz&lt;/code&gt;) keeps a current path. As in Unix, you can write paths in an absolute or relative syntax, and as in Unix &lt;code&gt;/&lt;/code&gt; is the path separator. Everything else is completely different.&lt;/p&gt;

&lt;p&gt;Let&amp;#8217;s use the REPL to print out some paths. First, here&amp;#8217;s the current path or something like it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; /~waclux-tomwyc/try/~2013.9.1
[&amp;#39;~waclux-tomwyc&amp;#39; %try &amp;#39;~2013.9.1&amp;#39; ~]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For complicated reasons related to the Hoon type system - which, for a higher-order functional type inference engine, is as stupid as we could make it - this noun gets rendered as a tuple rather than a path. We can rectify this with a cast:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; `path`/~waclux-tomwyc/try/~2013.9.1
/~waclux-tomwyc/try/~2013.9.1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;#8217;s the same value, just printed differently. Except for the date, this is the same as your current path:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; `path`%
/~waclux-tomwyc/try/~2013.9.1..17.49.18..282e&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The current date, of course, is always changing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; `path`%
/~waclux-tomwyc/try/~2013.9.1..17.50.39..7e38&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just to remind ourselves that these are Hoon expressions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; `path`/(scot %p -&amp;gt;-)/try/(scot %da (add ~d7 -&amp;lt;-))
/~waclux-tomwyc/try/~2013.9.8..17.55.03..b2ae&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;#8217;s you next week. It&amp;#8217;s black magic, don&amp;#8217;t worry about it. Let&amp;#8217;s get back to relative paths.&lt;/p&gt;

&lt;p&gt;A relative path is a function of the current path. First, let&amp;#8217;s make the current path interesting by moving to something deeper:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :cd /=main=/foo/bar/baz/bam
~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hey, wait, we actually used a relative path here. The simplest kind of relative path matches the current path by replacing a path component with &lt;code&gt;=&lt;/code&gt;. So we could just as well have said&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; -&amp;lt;+
&amp;#39;~2013.9.1..21.38.34..7a08&amp;#39;
~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; :cd /~waclux-tomwyc/main/[-&amp;lt;+]/foo/bar/baz/bam&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why is &lt;code&gt;-&amp;lt;+&lt;/code&gt; the current date as text? Look, we&amp;#8217;re trying to learn Arvo without too much Hoon here. Just accept that it is. In this context, anyway. Notice also that the prompt uses a relative path when (as is usually the case) the current case is just the present time, so that we don&amp;#8217;t have to stare at&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/main/~2013.9.1..21.38.34..7a08/foo/bar/baz/bam&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In any case, we can now use &lt;code&gt;=&lt;/code&gt; to our heart&amp;#8217;s content. Notice that you don&amp;#8217;t need &lt;code&gt;/&lt;/code&gt; to separate content from &lt;code&gt;=&lt;/code&gt;. &lt;code&gt;==&lt;/code&gt; is perfectly fine, too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; `path`/=
/~waclux-tomwyc
~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; `path`/==
/~waclux-tomwyc/main
~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; `path`/===
/~waclux-tomwyc/main/~2013.9.1..21.46.46..b250
~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; `path`/===zebra==
/~waclux-tomwyc/main/~2013.9.1..21.47.45..9ec8/zebra/bar/baz&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I guess you could do this on Unix. With awk or something. It&amp;#8217;s apparently been some time since the Nixon administration - how about a new OS? Anyway, there&amp;#8217;s another way to edit paths - with &lt;code&gt;%&lt;/code&gt;, which we&amp;#8217;ve seen before, from the end -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; `path`%
/~waclux-tomwyc/main/~2013.9.1..21.53.17..07f6/foo/bar/baz/bam
~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; `path`%/frampton/comes/alive
/~waclux-tomwyc/main/~2013.9.1..21.55.53..8c5f/foo/bar/baz/bam/frampton/comes/alive&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unix can back up with &lt;code&gt;..&lt;/code&gt;. We do the same with multiple &lt;code&gt;%&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; `path`%%
/~waclux-tomwyc/main/~2013.9.1..22.22.51..34a1/foo/bar/baz
~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; `path`%%%
/~waclux-tomwyc/main/~2013.9.1..22.22.53..a332/foo/bar
~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; `path`%%%%
/~waclux-tomwyc/main/~2013.9.1..22.22.55..4909/foo
~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; `path`%%%%/frampton/comes/alive
/~waclux-tomwyc/main/~2013.9.1..22.23.02..9b05/foo/frampton/comes/alive&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we can use &lt;code&gt;%&lt;/code&gt; as a separator and edit both prefix and suffix. In this case, &lt;code&gt;=&lt;/code&gt; is assumed up to the endpoint edit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; `path`/=zebra%%%%/frampton/comes/alive
/~waclux-tomwyc/zebra/~2013.9.1..22.26.39..e76d/foo/frampton/comes/alive&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus concludes our edition of Path School. Let&amp;#8217;s go back to the default desk (&lt;code&gt;try&lt;/code&gt;, meant for experiments only):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/main=/foo/bar/baz/bam&amp;gt; :cd /=try=
~waclux-tomwyc/try=&amp;gt; &lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#39;14_actual_editing&#39;&gt;1.4 Actual editing&lt;/h1&gt;

&lt;p&gt;But wait! There seem to be a bunch of files in your ship. How did they get there? Oh, right, installation automatically checked them out of &lt;code&gt;~zod&lt;/code&gt; or &lt;code&gt;~doznec&lt;/code&gt;. That&amp;#8217;s one way to get files. We&amp;#8217;ll see more of this in a little bit.&lt;/p&gt;

&lt;p&gt;Another way is to cook your files up within Arvo itself. We&amp;#8217;ll see this in the next chapter, but it&amp;#8217;s worth noting its limitations - no one has ported &lt;code&gt;vim&lt;/code&gt; to Arvo yet, nor will for a long time.&lt;/p&gt;

&lt;p&gt;The easiest way to get data in and out of Arvo is just to sync. You&amp;#8217;ll find a complete copy of your ship&amp;#8217;s filesystem, as of the current date, in your &lt;code&gt;$URBIT_HOME&lt;/code&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :cat %/bin/goodbye/hoon
|=  *
|=  [planet=tape ~]
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hello, {planet}.&amp;quot;)]
~waclux-tomwyc/try=&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then either stop the server with ^D, or switch to another window:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;oxford:~/urbit; cat $URBIT_HOME/waclux-tomwyc/try/bin/goodbye.hoon
|=  *
|=  [planet=tape ~]
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hello, {planet}.&amp;quot;)]
oxford:~/urbit; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you see, the dot-extension pattern in Unix gets converted to a path slash in Arvo. Otherwise, the mapping is straightforward. Legal Arvo paths are a strict subset of Unix paths - for example, uppercase characters are not allowed - so the round trip is always clean. So long as Urbit is always the primary state and Unix is only a derived view, this works great.&lt;/p&gt;

&lt;p&gt;Edit &lt;code&gt;$URBIT_HOME/waclux-tomwyc/try/bin/goodbye.hoon&lt;/code&gt;, in another window or while the server is down, then restart the server. As soon as you enter any keyboard input in &lt;code&gt;vere&lt;/code&gt;, you&amp;#8217;ll see&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;: /~waclux-tomwyc/try/2/bin/goodbye/hoon
~waclux-tomwyc/try=&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go ahead and type&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :goodbye &amp;quot;world&amp;quot;
&amp;quot;goodbye, world.&amp;quot;
~waclux-tomwyc/try=&amp;gt; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happened here? Arvo, of course, cannot make system calls and does not have any access at all to the Unix filesystem. But Arvo processes an event stream which the Unix program &lt;code&gt;vere&lt;/code&gt; follows, and generates actions which &lt;code&gt;vere&lt;/code&gt; applies. If you know Git, the best way to see &lt;code&gt;$URBIT_HOME&lt;/code&gt; is as a working directory in which changes are automatically committed.&lt;/p&gt;

&lt;h1 id=&#39;15_local_revision_control&#39;&gt;1.5 Local revision control&lt;/h1&gt;

&lt;p&gt;Now you&amp;#8217;re ready to see the full power of this fully armed and operational revision-controlled filesystem.&lt;/p&gt;

&lt;p&gt;Of course, you can build a revision-control system on top of Unix. And many have. That doesn&amp;#8217;t make Unix a revision-control system, though. VMS had something of the sort. (Some of us are so old we actually used VMS.) But VMS had&amp;#8230; other issues&amp;#8230;&lt;/p&gt;

&lt;p&gt;Again, an Arvo path starts with &lt;code&gt;/ship/desk/case&lt;/code&gt;. The case, ie version, applies to the whole desk, ie, project. When we edited &lt;code&gt;/=try=/bin/goodbye/hoon/&lt;/code&gt;, our change created case &lt;code&gt;2&lt;/code&gt; of &lt;code&gt;/~waclux-tomwyc/try&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;All paths are immutable and referentially transparent. Once we&amp;#8217;ve made our change, both cases of &lt;code&gt;/~waclux-tomwyc/try&lt;/code&gt; exist (logically; they&amp;#8217;re not actually copied, of course):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :cat /=try/1/bin/goodbye/hoon
|=  *
|=  [planet=tape ~]
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hello, {planet}.&amp;quot;)]

~waclux-tomwyc/try=&amp;gt; :cat /=try/2/bin/goodbye/hoon
|=  *
|=  [planet=tape ~]
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;goodbye, {planet}.&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time also works as you&amp;#8217;d expect. Remember, &lt;code&gt;=&lt;/code&gt; as the case means &amp;#8220;at the current time&amp;#8221;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :cat /=try=/bin/goodbye/hoon
|=  *
|=  [planet=tape ~]
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;goodbye, {planet}.&amp;quot;)]

~waclux-tomwyc/try=&amp;gt; :cat /=try/(scot %da (sub -&amp;lt;- ~m1))/bin/goodbye/hoon
|=  *
|=  [planet=tape ~]
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hello, {planet}.&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ie, now it&amp;#8217;s goodbye and a minute ago it was hello. This is anything but fancy. Finally, let&amp;#8217;s label it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :label %try %zebra
= new /~waclux-tomwyc/try/3

~waclux-tomwyc/try=&amp;gt; :cat /=try/zebra/bin/goodbye/hoon
|=  *
|=  [planet=tape ~]
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;goodbye, {planet}.&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that adding a label is part of the delta stream and creates a new change number, &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What&amp;#8217;s more, these revisions don&amp;#8217;t just apply in &lt;code&gt;:cat&lt;/code&gt;. Of course, this is a program and it exists to be run. Normally when we say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :goodbye &amp;quot;world&amp;quot;
&amp;quot;goodbye, world.&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this actually does a path search and ends up as a shorthand for&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :=/try=/bin/goodbye &amp;quot;world&amp;quot;
&amp;quot;goodbye, world.&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But of course, we can use the full revision notation here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :=/try/1/bin/goodbye &amp;quot;world&amp;quot;
&amp;quot;hello, world.&amp;quot;
~waclux-tomwyc/try=&amp;gt; :=/try/2/bin/goodbye &amp;quot;world&amp;quot;
&amp;quot;goodbye, world.&amp;quot;
~waclux-tomwyc/try=&amp;gt; :=/try/new/bin/goodbye &amp;quot;world&amp;quot;
&amp;quot;goodbye, world.&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yeah, I guess that&amp;#8217;s kind of cool. But&amp;#8230; actually&amp;#8230;&lt;/p&gt;

&lt;p&gt;Arvo is anything but a fancy revision control system - partly because it&amp;#8217;s a very young one, partly because it&amp;#8217;s cool to be crude. However, making revision control part of the OS, not on top of the OS, opens up&amp;#8230; certain&amp;#8230; possibilities.&lt;/p&gt;

&lt;p&gt;What happens if we try to use a revision that doesn&amp;#8217;t exist yet? Remember that the &lt;code&gt;new&lt;/code&gt; label was change &lt;code&gt;3&lt;/code&gt;. But suppose we try&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :=/try/4/bin/goodbye &amp;quot;world&amp;quot;
[waiting...]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hm? Again, either quit with ^D, or use another window; edit &lt;code&gt;$URBIT_HOME/waclux-tomwyc/try/bin/goodbye.hoon&lt;/code&gt;. Change &amp;#8220;goodbye&amp;#8221; to &amp;#8220;hasta la vista.&amp;#8221; Then, &lt;code&gt;bin/vere mypier&lt;/code&gt; if you quit, or just hit space to trigger the sync.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vere: urbit home is /Users/cyarvin/Documents/src/u3/urb
loom: loaded 10MB
time: ~2013.9.2..07.26.20..b510
ames: on localhost, UDP 31337.
http: live on 8080
rest: checkpoint to event 965
rest: old 0v16.5un6m, new 0v1i.il78t

---------------- playback complete----------------
: /~waclux-tomwyc/try/4/bin/goodbye/hoon
&amp;quot;hasta la vista, world.&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Neighbor, tell me you&amp;#8217;ve seen &lt;em&gt;that&lt;/em&gt; before. Or with labels:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :=/try/crazy/bin/goodbye &amp;quot;world&amp;quot;
[waiting...]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use ^X to get a prompt back while this task waits. Then, create the label:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :=/try/crazy/bin/goodbye &amp;quot;world&amp;quot;
~waclux-tomwyc/try=&amp;gt; :label %try %crazy
= crazy /~waclux-tomwyc/try/5
&amp;quot;hasta la vista, world.&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;#8217;s going on here? What&amp;#8217;s going on is that the Arvo filesystem is an immutable, ie, referentially transparent, namespace. Since every path will only be bound to one file, when we encounter a path that&amp;#8217;s not yet bound (but could be bound in future), we do every OS&amp;#8217;s favorite thing - we &lt;em&gt;block&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Civilization, a wise man once said, is the set of events you can block on. What&amp;#8217;s happening here is not in principle difficult at all. It is pretty hard to do, however, if your revision control system is not in intimate proximity to your scheduler.&lt;/p&gt;

&lt;p&gt;It would be difficult, we feel, to argue that this isn&amp;#8217;t cool. But one could argue that it&amp;#8217;s just a party trick. But once your revision control system and your scheduler are jammed into one phone booth&amp;#8230; why not jam networking in there too?&lt;/p&gt;

&lt;h1 id=&#39;16_network_revision_control&#39;&gt;1.6 Network revision control&lt;/h1&gt;

&lt;p&gt;Arvo is the OS. Urbit is the network. In theory you could write an Urbit client that wasn&amp;#8217;t Arvo, though it&amp;#8217;s hard to see why. But it seems unseemly to erase this distinction entirely.&lt;/p&gt;

&lt;p&gt;So&amp;#8230; let&amp;#8217;s do some networking. Arvo is an immutable namespace. But&amp;#8230; Urbit is a &lt;em&gt;global&lt;/em&gt; immutable namespace.&lt;/p&gt;

&lt;p&gt;We sent you two destroyers, right? You could run them both from the same pier (ie, from the same Unix process), but this would be confusing for a newb. So it&amp;#8217;s time to make a new window and boot up your second ship. Let&amp;#8217;s say it&amp;#8217;s &lt;code&gt;~wolnum-sorleb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vere -c otherpier&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And follow the same directions as above. If it worked, you should be able to say hi to yourself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~wolnum-sorleb/try=&amp;gt; :hi ~waclux-tomwyc &amp;quot;welcome to Urbit&amp;quot;
; ~waclux-tomwyc is your neighbor
; ~waclux-tomwyc: &amp;quot;this is fun&amp;quot;

; ~wolnum-sorleb is your neighbor
~waclux-tomwyc/try=&amp;gt; :hi ~wolnum-sorleb &amp;quot;this is fun&amp;quot;
; ~wolnum-sorleb: &amp;quot;welcome to Urbit&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Neighbors are Urbit ships that have completed a symmetric key exchange. In most cases they will also be communicating via direct UDP packets, though if both sides are behind bad NAT gateways the (encrypted) packets have to bounce through our servers.)&lt;/p&gt;

&lt;p&gt;Okay, that seemed to work. Now we can use the global namespace as if &lt;em&gt;the whole world was one giant computer&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :cat /~wolnum-sorleb/try=/bin/goodbye/hoon
[waiting...]
|=  *
|=  [planet=tape ~]
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hello, {planet}.&amp;quot;)]

~waclux-tomwyc/try=&amp;gt; :~wolnum-sorleb/try=/goodbye &amp;quot;world&amp;quot;
[waiting...]
&amp;quot;hello, world.&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whoa.&lt;/p&gt;

&lt;p&gt;But perhaps that was a little slow. The network isn&amp;#8217;t very well tuned yet, and there are several roundtrips as we request config files that aren&amp;#8217;t actually there for this trivial app.&lt;/p&gt;

&lt;p&gt;Moreover, if we try it again, it&amp;#8217;ll be slow again, because we are requesting files at the current date with that &lt;code&gt;try=&lt;/code&gt;. Let&amp;#8217;s try to use a label instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :~wolnum-sorleb/try/alpha/goodbye &amp;quot;world&amp;quot;
[waiting...]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hey, whoops. That label doesn&amp;#8217;t exist yet. So, our process will block forever until it does. Let&amp;#8217;s go over to the other side and create it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~wolnum-sorleb/try=&amp;gt; :label %try %alpha
= alpha /~wolnum-sorleb/try/2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At which point you&amp;#8217;ll see&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :~wolnum-sorleb/try/alpha/goodbye &amp;quot;world&amp;quot;
&amp;quot;hello, world.&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty cool, right? Now try it again. Since bindings are permanent, it won&amp;#8217;t hit the network at all:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :~wolnum-sorleb/try/alpha/goodbye &amp;quot;world&amp;quot;
&amp;quot;hello, world.&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#8217;s try it with some data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclyx-tomwyc/try=&amp;gt; (mul 10 ^:@/~zod/try/beta/doc/fortytwo/noun)
[waiting...]

~wolnum-sorleb/try=&amp;gt; :ram /===/doc/fortytwo/noun; (mul 6 7)
+ /~wolnum-sorleb/try/3/doc/fortytwo/noun
~wolnum-sorleb/try=&amp;gt; :label %try %beta
  
~waclyx-tomwyc/try=&amp;gt; (mul 10 ^:@/~zod/try/beta/doc/fortytwo/noun)
420&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So not only can you use any data in Urbit, on the command line or in a program, as if it were a constant - if the data isn&amp;#8217;t available yet, your task will block until it is.&lt;/p&gt;

&lt;p&gt;Of course, a cynic would say, this is just a party trick too. True enough! But perhaps it&amp;#8217;ll get the party&amp;#8217;s attention.&lt;/p&gt;

&lt;p&gt;Obviously, what&amp;#8217;s going on here is that a file request is just a special case of a subscribe operation. An attempt to use a resource, local or remote, that isn&amp;#8217;t ready, is automatically treated as a subscription to that resource, and creates state on the server that owns it which will be activated once the resource does exist. (And if you kill the requesting task on the client, yes, it will cancel the request on the server.)&lt;/p&gt;

&lt;p&gt;It&amp;#8217;s the combination of a purely functional language and OS with a secure, referentially transparent global namespace that makes Urbit a qualitatively different programming experience. APIs are great and REST is an attempt to make the Web almost functional, but at bottom a Web request remains a side effect in a mutable system. While Urbit requests are built on a message queue layer which you can use if you like, simply sharing data (and/or code) isn&amp;#8217;t a matter of APIs, requests, installs, etc. You just use it.&lt;/p&gt;

&lt;p&gt;It is of course possible to build the same kinds of services with 20th-century Web protocols. Just as there are revision control servers on the Internet, there are pretty good (certainly much more featureful) publish-and-subscribe protocols over HTTP. But such protocols are standalone systems, and difficult to integrate with each other in a single programming environment and service layer.&lt;/p&gt;

&lt;h1 id=&#39;17_classic_unix_crap&#39;&gt;1.7 Classic Unix crap&lt;/h1&gt;

&lt;p&gt;If a real OS runs on the bare hardware and is preemptive, it&amp;#8217;s clear that Arvo is not a real OS and will never be one. It will always run on Unix. Of course in a sense it comes to bury Unix, but also to praise it - to imitate it - and even to surpass it. Unix today is ancient, bloated and debilitated, but its historic greatness is eternal. Comparing Unix to other OSes of its time is comparing Shakespeare to other playwrights of his time.&lt;/p&gt;

&lt;p&gt;But, ya know, times change. How do we surpass Unix? We&amp;#8217;ve got two words for you - typed pipes! Yeah, Arvo has typed pipes. It also has typed arguments and even typed configurations. These types are probably not quite the types you&amp;#8217;re used to, if you&amp;#8217;re a language geek (Hoon doesn&amp;#8217;t do PL theory), but they do the same job and pretty well if we say so ourselves.&lt;/p&gt;

&lt;p&gt;Broadly speaking, an Arvo task is a function that consumes events and produces effects. When you learn Hoon, we&amp;#8217;ll return to what this actually means. For now, this is a good excuse to see the classic server process that consumes events and produces effects - a Web server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~waclux-tomwyc/try=&amp;gt; :game &amp;quot;Elvis&amp;quot;
[waiting...]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Point your browser at &lt;code&gt;localhost:$PORT/game/fun&lt;/code&gt;, where $PORT is the HTTP port shown when you started &lt;code&gt;vere&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http: live on 8080&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hit &lt;code&gt;^C&lt;/code&gt; on the task when you&amp;#8217;re done. Try editing the page or the application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/=try=/bin/game/hoon
$URBIT_HOME/waclux-tomwyc/bin/game.hoon

/=try=/doc/web/game/fun/hoon
$URBIT_HOME/waclux-tomwyc/doc/web/game/fun.hoon&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then hitting reload. You&amp;#8217;ll see that you need to restart the server to change the app, but not to change the page.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;fun.hoon&lt;/code&gt; is not a template language - just Hoon. Hoon is good at synthesizing hierarchical data structures and does not need a DSL to generate XML, thank you very much.&lt;/p&gt;

&lt;p&gt;Lorem ipsum&amp;#8230;&lt;/p&gt;

&lt;h1 id=&#39;18_update_upgrading_and_continuity&#39;&gt;1.8 Update, upgrading and continuity&lt;/h1&gt;

&lt;p&gt;To update the&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Chapter 0 &#58; Introduction and philosophy</title>
   <link href="http://urbit.org/2013/08/22/Chapter-0-intro.html"/>
   <updated>2013-08-22T00:00:00-04:00</updated>
   <id>http://urbit.org/2013/08/22/Chapter-0-intro</id>
   <content type="html">&lt;p&gt;Urbit is a new programming and execution environment designed from scratch. Any resemblance to existing languages or operating systems is coincidental, cosmetic, or inevitable.&lt;/p&gt;

&lt;h2 id=&#39;urbit_is_a_stack&#39;&gt;Urbit is a stack&lt;/h2&gt;

&lt;p&gt;Nock is a stateless virtual machine defined in 200 words. The Nock machine is sealed - all execution is &amp;#8220;pure.&amp;#8221; Nock&amp;#8217;s goal is extreme commoditization of computing semantics.&lt;/p&gt;

&lt;p&gt;Hoon is a high-level language which defines itself in Nock. Its self-compiling kernel, 7000 lines of code, specifies Hoon unambiguously; there is no Hoon spec. Hoon can be classified as a pure, strict higher-order static type-inferred functional language, with co/contra/bivariance and genericity. However, Hoon does not use lambda calculus, unification, or other constructs from &amp;#8220;PL theory.&amp;#8221; Hoon also excels at handling and validating untyped data, a common task on teh Internets. Its syntax is entirely novel and initially quite frightening.&lt;/p&gt;

&lt;p&gt;Arvo is a deterministic functional operating system defined in Hoon. While still basically a toy, it can serve web apps and network securely with other Arvo instances. An Arvo instance is designed to be a simple independent computer in the cloud.&lt;/p&gt;

&lt;p&gt;It&amp;#8217;s possible to use Nock without Hoon, but there is no obvious reason to do so. It&amp;#8217;s not necessary to learn Nock to learn Hoon, but it helps a lot. The same for Hoon and Arvo. Therefore, we&amp;#8217;ll work through all three in order. in order. If you&amp;#8217;re convinced that you want to learn Urbit, feel free to skip the justifications below.&lt;/p&gt;

&lt;h2 id=&#39;nock&#39;&gt;Nock&lt;/h2&gt;

&lt;p&gt;Nock is a virtual machine, like the Java VM or Microsoft CLR. Just as you execute Java by compiling it to the JVM, you execute Hoon by compiling it to Nock.&lt;/p&gt;

&lt;p&gt;Do you need to learn Nock to learn Hoon? In theory, no, just as you don&amp;#8217;t need to know anything about the JVM to learn Java. Indeed, in theory we could compile Hoon to the JVM (or Java to Nock). What&amp;#8217;s the difference between Nock and the JVM, anyway? Why do we need a new virtual machine? And since we&amp;#8217;ll only be programming in Hoon, why do we care how Hoon is executed?&lt;/p&gt;

&lt;p&gt;There is no formal difference between Nock and the JVM. In theory, both are Turing-complete computers. In practice, they have just about nothing in common.&lt;/p&gt;

&lt;p&gt;The main practical difference is that Nock is two orders of magnitude simpler. The JVM spec is a book. The Nock spec is 200 words; it fits on a T-shirt; it gzips to 371 bytes. There are lots of other differences, but all follow from this.&lt;/p&gt;

&lt;p&gt;Why does size matter? The goal of any programming language is to become a standard. Universal standardization equals world domination. The simpler a specification is, the easier to standardize. Nock is a practical interpreter as simple as the most frozen and fundamental of protocols or formats: IPv4, XML, JSON. A 200-word spec needs a standards process like a fish needs swim lessons. When a T-shirt goes to war with a book, it&amp;#8217;s like tanks against cavalry - or should be, anyway.&lt;/p&gt;

&lt;p&gt;Since every program in Hoon (including the Hoon compiler) reduces to Nock, every program in Hoon inherits Nock&amp;#8217;s precision. If two Nock interpreters produce different results, one is wrong, and it is always easy to tell which - without a &amp;#8220;standards lawyer.&amp;#8221; Can we imagine the end of incompatiblity?&lt;/p&gt;

&lt;p&gt;Essential to actually realizing this promise is a second difference between Nock and the JVM, which is that the JVM can call Unix system calls and libraries, and Nock can&amp;#8217;t. Nock has no &amp;#8220;native methods&amp;#8221; or foreign-function interface. Nor is it ever extended, embellished, forked, improved or advanced.&lt;/p&gt;

&lt;p&gt;Java began as a portable language; so did C. Most Java today is server-side Java, dependent no less than C on library and OS configuration. It is possible to write portable Java; it is possible to write portable C. It is not possible to write unportable Nock or Hoon. It is also not possible to write insecure Nock or Hoon, unless your interpreter is so broken there&amp;#8217;s an actual hole in its skull.&lt;/p&gt;

&lt;p&gt;How does Nock obtain native CPU performance, if it can&amp;#8217;t call native code? This is actually a much more pressing problem in Nock than in conventional virtual machines, like the JVM, because naive Nock is hopelessly inefficient. Nock is defined in a page of pseudocode, and a naive interpreter can be written in a page of any language. But since Nock&amp;#8217;s only arithmetic operator is increment, decrement in your one-page interpreter is an &lt;code&gt;O(n)&lt;/code&gt; operation. Addition is &lt;code&gt;O(n^2)&lt;/code&gt;. And so on.&lt;/p&gt;

&lt;p&gt;The programmer cannot solve this problem by calling a C function, because Nock can&amp;#8217;t do that. In theory, an optimizing Nock interpreter might be able to analyze the code and reduce it to a simpler equivalent. But this would be a true research problem.&lt;/p&gt;

&lt;p&gt;Instead, a practical Nock engine simply recognizes code it knows and substitutes equivalent C functions, or &amp;#8220;jets.&amp;#8221; For instance, in theory there are many different ways to express decrement in Nock, but in practice the Nock interpreter will execute only one: the decrement function in the Hoon kernel. Therefore, the only Nock decrement that must be optimized is the code that Hoon generates when it compiles its own decrement. All others will suck, so don&amp;#8217;t roll your own. Code recognition, as opposed to code analysis, is not a research problem.&lt;/p&gt;

&lt;p&gt;Jet propulsion separates mechanism and policy, transferring the task of achieving native performance from the programmer to the sysadmin. The Hoon programmer must still use hints to mark functions for jet recognition, but cannot control or discern how these functions are actually executed. Of course, a correct jet is indistiguishable in every way, except timing, from naive Nock. The 200-word spec defines the result, not the algorithm.&lt;/p&gt;

&lt;p&gt;We can see a jet as a sort of &amp;#8220;functional device driver.&amp;#8221; For instance, an OpenGL programmer today has no idea whether her GL operations are implemented in software or by a GPU. This abstraction is essential to modern graphics programming.&lt;/p&gt;

&lt;p&gt;When we compare jets to native calls, what are the pros and cons? Jets have only one disadvantage: high-performance code must be written twice, once in Hoon and once in C. Indeed, from the C programmer&amp;#8217;s perspective, Hoon is a specification language for your C functions. Hoon specifications are executable, of course, so you can test the two implementations against each other - again, transparently to the programmer. Moreover, the jet can even fail in special cases and drop back to the interpreter.&lt;/p&gt;

&lt;p&gt;Hoon ships with a Nock that jet-propels most of the Hoon kernel, including most of the Hoon compiler. If you&amp;#8217;re wondering how we wrote Hoon in Hoon when we didn&amp;#8217;t have Hoon, the answer is that we wrote Hoon in C and evolved this C code into a mere jet. This process is not recommended unless absolutely necessary - by far the best way to write the jet pair is to write the Hoon first.&lt;/p&gt;

&lt;h2 id=&#39;hoon&#39;&gt;Hoon&lt;/h2&gt;

&lt;p&gt;If I can summarize Hoon&amp;#8217;s goal, it&amp;#8217;s to be the C of functional programming. If you&amp;#8217;re not so arthritic that you learned to code in Turbo Pascal, you may never fully appreciate the metaphor.&lt;/p&gt;

&lt;p&gt;All languages in the Algol procedural family, including both C and Pascal, map straightforwardly onto a conventional CPU. But Pascal and C handle this mapping very differently. Pascal and C both have pointers and arrays, but Pascal works hard to treat both pointers and arrays as mathematical abstractions. C drops the abstraction; it makes no bones about the fact that a pointer is a memory address.&lt;/p&gt;

&lt;p&gt;To a Pascal purist, to anyone who thinks mathematically, this seemed hideous. C isn&amp;#8217;t really a high-level language at all - it&amp;#8217;s a glorified macro assembler. Mankind retreats to the cave. But to programmers who are not natural mathematicians, whose minds are mechanical rather than abstract, C is a lifesaver. Since most mathematicians are also good mechanical thinkers, whereas very few people are naturally adept at abstraction, C slew and pillaged the once promising empire of Pascal.&lt;/p&gt;

&lt;p&gt;There are two broad families of functional language available today: Haskell/ML, and Lisp. The Haskell family is relatively abstract; the Lisp family, relatively concrete. Perhaps Lisp is about as abstract as Pascal; Haskell is far more abstract. Both rest on the fundamental abstraction of functional programming, the lambda calculus, and more generally the foundational metamathematics of the late 19th and early 20th centuries.&lt;/p&gt;

&lt;p&gt;Hoon has nothing to do with any of this stuff. It has functions and types, or what appear to be functions and types. On closer inspection, they are not abstractions at all, just glorified Nock macros.&lt;/p&gt;

&lt;p&gt;If we compare these concrete patterns to the genuine abstractions of Haskell, we see that - as with Pascal and C - Hoon is roughly as expressive as Haskell. Haskell has higher-order type inference; Hoon has &amp;#8220;higher-order&amp;#8221; &amp;#8220;type&amp;#8221; &amp;#8220;inference.&amp;#8221; Some Haskell extensions have dependent types - Hoon has &amp;#8220;refined&amp;#8221; &amp;#8220;types.&amp;#8221; Hoon, like Lisp, unlike Haskell, is also very comfortable with typeless data; it should be, because it has no types, only &amp;#8220;types.&amp;#8221; The Hoon features and the Haskell abstractions have nothing in common - except that they solve the same problems for you, the programmer. In short, Hoon next to Haskell is a white shark next to a killer whale. The apparent resemblance is strictly superficial.&lt;/p&gt;

&lt;p&gt;So we could describe Hoon as a pure, strict, higher-order typed functional language. But don&amp;#8217;t do this in front of a Haskell purist, unless you put quotes around &amp;#8220;typed,&amp;#8221; &amp;#8220;functional,&amp;#8221; and possibly even &amp;#8220;language.&amp;#8221; We could also say &amp;#8220;object-oriented,&amp;#8221; with the same scare quotes for the cult of Eiffel.&lt;/p&gt;

&lt;p&gt;Knowing Pascal made it harder, not easier, to learn C. Knowing Haskell or Lisp makes it harder to learn Hoon. Indeed, knowing either would have made it impossible for me to write Hoon. I do know C, of course, and the spirit of K&amp;amp;R is all over Hoon. Or so I&amp;#8217;d like to think. Just as C is little more than a macro assembler for machine code, Hoon is little more than a macro assembler for Nock.&lt;/p&gt;

&lt;p&gt;The most basic difference between Hoon and other languages is that Hoon is defined in Hoon. There is no formal Hoon spec - just a self-compiling compiler written in Hoon. The target of this compiler is, of course, Nock. Thus Hoon is as precisely defined as Nock, which is quite precisely indeed.&lt;/p&gt;

&lt;p&gt;This would be true regardless of the size of Hoon in Hoon, but Hoon in Hoon is in fact quite small. The Hoon kernel is 7000 lines; it gzips to 25K. But this includes not only the self-compiling compiler, but also all the standard libraries it needs. The compiler alone is 2500 lines, including a very intricate &amp;#8220;monadic&amp;#8221; parser, a non-Hindley-Milner &amp;#8220;type inference&amp;#8221; engine, and a Nock code generator. This reflects both the internal simplicity of Hoon and its expressiveness. If you know these 2500 lines, and an expert should, you &lt;em&gt;know&lt;/em&gt; Hoon.&lt;/p&gt;

&lt;p&gt;On the other hand, the &lt;em&gt;apparent&lt;/em&gt; complexity of Hoon is very high. When you open a Hoon file, you are confronted with an enormous avalanche of barely structured line noise. Again this reminds us of C, which makes no attempt at the kind of abstract prettiness we expect from a Pascal or a Haskell. Learning Hoon involves learning nearly 100 ASCII digraph &amp;#8220;runes.&amp;#8221;&lt;/p&gt;

&lt;p&gt;Is this a harsh learning curve? Of course it is. On the other hand, it is not a mathematical task, but a mechanical one. It is trivial compared to the task of learning the Chinese alphabet, memorizing the Qu&amp;#8217;ran, etc, all rote mental tasks routinely performed by normal human 11-year-olds. If you have an 11-year-old who understands the Hindley-Milner algorithm, you have a remarkable young mathematician.&lt;/p&gt;

&lt;p&gt;A practical programming language is first and foremost a UI for programmers - meaning human programmers. Concrete languages beat abstract ones because they play to the strengths of the human brain, and avoid its weaknesses. Functional programming is traditionally reserved for the topmost echelon of natural talent. I&amp;#8217;d like to think that anyone who can learn to fix a Chevy can learn to write a Hoon function. We&amp;#8217;ll see if that&amp;#8217;s true.&lt;/p&gt;

&lt;p&gt;A programming language is called a language for a reason - it should activate the human linguistic lobes. Learning Hoon is like learning a language very alien to your first, such as Chinese from English. Before you know Hoon, it looks like squiggles. Once you know Hoon, and the rote task of syntax processing is hardwired, you look at your screen and &lt;em&gt;see&lt;/em&gt; the function. Or, at least, I do - I hope you can too.&lt;/p&gt;

&lt;h2 id=&#39;arvo&#39;&gt;Arvo&lt;/h2&gt;

&lt;p&gt;Lorem ipsum.&lt;/p&gt;</content>
 </entry>
 
 
</feed>
