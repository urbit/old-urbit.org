<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Urbit - Chapter 4 &#58; Hoon - Syntax</title>
  <meta name="author" content="Urbit" />
  <meta name="description" content="The blog of Urbit" />
  <link rel="canonical" href="http://example.com/2013/08/22/Chapter-4-syntax.html" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="alternate" type="application/rss+xml" title="Urbit" href="http://example.com/atom.xml" />

  <link rel="stylesheet" href="/assets/css/all.css">
<!--[if IE 7]>
  <link rel="stylesheet" href="/assets/css/font-awesome-ie7.min.css">
<![endif]-->
</head>
<body>
  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <a href="/">
    <img src="/logo.svg" id="logo" alt="logo"/>
  </a>
  <h2> Urbit</h2>
  <hr/>
  <ul>
  <p>An operating function</p>
  <p>
   <a href="/">Documentation </a>
   <br>
   <a href="/">FAQ</a>
   <br/>
   <a href="/">Community</a>
  </p>
  <hr/>
  <div>
    <div id="social">
      Follow:
<div id="stalker">
  
  <a title="urbit on Github" href="http://github.com/urbit">
    <i class="icon-github-sign"></i>
  </a>
  

  
  <a title="urbit on Hacker News" href="http://news.ycombinator.com/user?id=urbit">
    <i class="icon-sign-blank"></i>
    <span class="icon-overlay icon-hn">Y</span>
  </a>
  
  
  <a title="urbit on Twitter" href="http://twitter.com/urbit">
    <i class="icon-twitter-sign"></i>
  </a>
  
  <a title="RSS feed" id="rss" href="/atom.xml">
    <i class="icon-rss-sign"></i>
  </a>
</div>

    </div>
  </div>
  </ul>
</nav>

    </div>

    <div class="eleven columns content">
      <p class="meta">
  <a href="/">
    <i class="home icon-home"></i>
  </a>
</p>

<h1 class="title">Chapter 4 &#58; Hoon - Syntax</h1>

<div id="post">
  <p>Now, let&#8217;s actually look at Hoon. Really, try not to recoil in horror. It&#8217;s actually not anything like line noise.</p>

<p>Open the Hoon kernel - <code>urb/les/arvo/hoon.hoon</code>. Let&#8217;s look at the full, official decrement function (line 549):</p>

<pre><code>++  dec
      ~/  %dec
      |=  a=@
      ^-  @
      ?&lt;  =(0 a)
      =+  b=@
      |-
      ?:  =(a +(b))
        b
      $(b +(b))</code></pre>

<p>Whaa?</p>

<p>Any attempt to understand this in terms of any language you already know would clearly be mistaken. In both syntax and semantics, learning to program in Hoon is learning to program all over again. When we say from scratch, we mean from scratch!</p>

<p>It&#8217;s actually worse than that - learning Hoon is learning to <em>read</em> all over again. Hoon is a keyword-free language - any alphanumeric text in the program is part of the program. Where other languages have reserved words, Hoon has squiggles.</p>

<p>We use so many of these ASCII glyphs that we like to be able to read them out loud. A language is meant to be <em>said</em>. The squiggles have conventional names, sort of, some of them, some of them easy to say, others not so much. So we&#8217;ve renamed them:</p>

<pre><code>ace  space      gal  &lt;          per  )
bar  |          gar  &gt;          sel  [
bas  \          hax  #          sem  ;
buc  $          hep  -          ser  ]
cab  _          kel  {          sig  ~
cen  %          ker  }          soq  &#39;
col  :          ket  ^          tar  *
com  ,          lus  +          tec  `
doq  &quot;          pam  &amp;          tis  =
dot  .          pat  @          wut  ?
fas  /          pel  (          zap  !</code></pre>

<p>You just have to memorize these names. Sorry.</p>

<p>But is this at least enough symbols? Alas, nowhere near. ASCII&#8217;s glyph supply is not the greatest, but we can make all the squiggles we need by forming digraphs, or <em>runes</em>.</p>

<p>To pronounce a rune, concatenate the glyph names, stressing the first syllable and softening the second vowel into a &#8220;schwa.&#8221; Hence, to say <code>~.</code>, say &#8220;sigdot.&#8221; To say <code>|=</code>, say &#8220;bartis.&#8221; Which has an inevitable tendency to turn into &#8220;barts&#8221; - a sin to be encouraged. In any language actually spoken by actual humans, laziness soon rounds off any rough edges.</p>

<p>So if we had to read the above decrement, omitting the spaces (which only a real purist would pronounce), we&#8217;d say: &#8220;luslus dec sigfas cen dec bartis a tis pat sigbar soq dec soq ketcab pat wutgal tis pel zero a per tislus b tis pat barhep wutcol tis pel a lus pel b per per b buc pel b lus pel b per per.&#8221; The authorities would then arrive, and drag us out in a big net. Definitely don&#8217;t do this at the airport.</p>

<p>Geeks being solitary by nature, opportunities for reading code aloud are limited. But studies by actual scientists have shown that even when we read silently, we activate the motor cortex that controls our vocal cords. Even if we never speak these squiggles, they&#8217;re easier to <em>think</em> if bound to simple sounds.</p>

<p>(And don&#8217;t worry if you can&#8217;t get yourself to say &#8220;lus&#8221; instead of &#8220;plus&#8221; for <code>+</code>, or &#8220;tar&#8221; instead of &#8220;star&#8221; for <code>*</code> - I have this problem myself. It&#8217;s much easier to replace &#8220;underscore&#8221; with &#8220;cab&#8221; or &#8220;ampersand&#8221; with &#8220;pam.&#8221;)</p>

<p>Hoon has almost 90 digraphic runes. They are easier to organize in your head, though, because the choice of glyph is not random. The second glyph in a rune means little or nothing, but the first defines a rough semantic category. These categories are:</p>

<pre><code>|  bar    gates (ie, functions) (ie, one-method cores)
?  wut    conditionals, booleans, tests
:  col    tuples
.  dot    nock operators
$  buc    factory macros (ie, type definitions) 
^  ket    type conversions
=  tis    compositions
%  cen    invocations
&amp;  pam    gears (ie, objects) (ie, multi-method cores)
~  sig    hints
;  sem    miscellaneous macros
!  zap    special operations</code></pre>

<p>Each rune has <em><span>not</span></em> its own doc file in the <code>rune/190</code> directory. The name of the file is the name of the rune, minus the vowels. Thus, <code>|=</code> or &#8220;bartis&#8221; is <em><span>not</span></em> defined in <code>rune/190/brts.txt</code>.</p>

<p>Opening this file, we see:</p>

<pre><code>%brts  |=  &quot;bartis&quot;

  define:
    [%brts p=gene q=gene]

  expand:
    [%brts *]  [%brcb p.gen (~(put by *(map term foot)) %% [%ash q.gen])]</code></pre>

<p>There should be some actual discussion, but there isn&#8217;t. Still, <code>brts.txt</code> is quite complete as a definition of <code>|=</code>. How? We need to step back a little.</p>

<p>When the Hoon parser parses a source file, it generates a noun called a <code>gene</code>. If you know what an AST is, a gene is an AST node. If you don&#8217;t, don&#8217;t worry about it.</p>

<p>Search the current kernel for <code>++  gene</code> - note double space. This code is both the type declaration for type <code>gene</code>, and a function that maps an untyped noun to a typed gene. In it you&#8217;ll see the above definition,</p>

<pre><code>[%brts p=gene q=gene]</code></pre>

<p>Ie, one kind of gene is a triple whose head is the constant <code>%brts</code>, and whose tail is a pair of genes, <code>p</code> and <code>q</code>.</p>

<p>We also see the semantics of this rune: it expands to</p>

<pre><code>[%brcb p.gen (~(put by *(map term foot)) %% [%ash q.gen])]</code></pre>

<p>ie, <code>|=</code> is a built-in macro. But back to syntax.</p>

<p>What is <code>%brts</code>? The atom also known as <code>1937011298</code> or <code>0x73747262</code>. Simply a string mapped to an unsigned integer, LSB first. It&#8217;s easy to see why the vowels got lost - <code>%bartis</code> is <code>126896762413410</code> or <code>0x736974726162</code>. On a 32-bit CPU with 31-bit direct atoms, <code>%brts</code> is direct and <code>%bartis</code> indirect (not that the programmer can tell the difference). But you still say &#8220;bartis.&#8221;</p>

<p>For instance, in the decrement above, we have</p>

<pre><code>|=  a=@
~|  &#39;dec&#39;
^-  @
?&lt;  =(0 a)
=+  b=@
|-
?:  =(a +(b))
  b
$(b +(b))</code></pre>

<p>In this <code>%brts</code>, <code>p</code> is</p>

<pre><code>a=@</code></pre>

<p>and <code>q</code> is</p>

<pre><code>~|  &#39;dec&#39;
^-  @
?&lt;  =(0 a)
=+  b=@
|-
?:  =(a +(b))
  b
$(b +(b))</code></pre>

<p>We are starting to see the principles of Hoon syntax. Let&#8217;s make them clear.</p>

<p>First, for any rune, the Hoon parser has two kinds of syntax: normal and custom. Most runes, such as <code>|=</code>, have only normal syntax without custom syntax. Almost all runes with custom syntax also have normal. Custom can mean anything; normal is rigid and uniform.</p>

<p>All programming languages, but especially functional ones, face two difficult syntactic problems. One is controlling the large numbers of terminators that appear in any deeply nested tree structure - Lisp is infamous for its piles of right parens. These are not a serious usability problem, except inasmuch as you consider ugly a usability problem (which I do). Two, a more serious concern, is keeping complex routines from flowing off the right margin as tab depth increases.</p>

<p>A glance at the more complex organs of the Hoon kernel reveals that Hoon is relatively untroubled by either of these woes. But why? One dubious panacea for the terminator problem is the use of significant whitespace. Whitespace in Hoon is not significant. (To be exact, the presence or absence of whitespace matters, but the quantity never does.)</p>

<p>The answer is that the normal syntax for every rune has two forms: &#8220;wide&#8221; and &#8220;tall.&#8221; As a functional language, Hoon does not distinguish between statements and expressions, but normal wide syntax is expression-like and tall is statement-like.</p>

<p>For instance, in our example above,</p>

<pre><code>?:  =(a +(b))
  b
$(b +(b))</code></pre>

<p>is a tall normal form. The equivalent wide form is</p>

<pre><code>?:(=(a +(b)) b $(b +(b)))</code></pre>

<p>It&#8217;s usually best to use the wide form if your gene fits on the line, but this is obviously an aesthetic choice. If your gene does not fit your margin (which should always be 80 columns), you have no choice but to go tall. For reasons that should be obvious, a tall gene can contain wide subgenes, but a wide gene cannot contain tall subgenes - just as, in procedural languages, a statement can contain expressions but not vice versa.</p>

<p>In the wide normal form, the rune is followed immediately (no whitespace) by a left paren (&#8220;pel&#8221;), then the subgenes with a single space between them, then a right paren (&#8220;per&#8221;) as terminator. If the rune was inside the parens rather than a prefix, this would be the Lisp syntax.</p>

<p>In the tall normal form, any quantity of whitespace follows the rune, and separates the subgenes from each other. Where is the terminator? There is no terminator - in most cases.</p>

<p>Consider the <code>?:</code> rune, &#8220;wutcol,&#8221; <code>%wtcl</code>. This is</p>

<pre><code>[%wtcl p=gene q=gene r=gene]</code></pre>

<p>Why should we need a terminator? We know <code>%wtcl</code>, whose semantics are if-then-else, has three subgenes. When the parser sees <code>?:</code> followed by space, it simply parses the next three genes and fills the rune with them.</p>

<p>This only works in runes with fixed tuple structure, which fortunately is most of them. A counterexample is <code>:*</code>, ie,</p>

<pre><code>[%cltr p=(list gene)]</code></pre>

<p>which is of variable length and needs a terminator. But we have no dangling parens, but an attractive tall closure:</p>

<pre><code>:*  %foo
        %bar 
        %baz
        %moo
    ==</code></pre>

<p>whose equivalent wide normal is</p>

<pre><code>:*(%foo %bar %baz %moo)</code></pre>

<p>which no one would ever write, preferring the custom</p>

<pre><code>[%foo %bar %baz %moo]</code></pre>

<p>This leaves only one question: indentation. Since space is not significant (even linebreaks are irrelevant - the newline is just another space), the use of whitespace in tall forms is purely a matter of style. Style is very important, however!</p>

<p>The first law of Hoon indentation style is that all tall indentation is in two-space increments. (Tabs are illegal. If you pollute a Hoon file with ASCII 9, not only will it not parse, but thugs in ski masks will kick down your door and shoot you. You laugh! Try it!) Single spaces are for wide only.</p>

<p>The second law of Hoon indentation is that everything in the kernel is good indentation style. Or at least if it&#8217;s not, it needs changed. The kernel shall be lapidary, noble, ideal and above all suspicion - a Doric column, a Tlingit totem pole, an Egyptian obelisk.</p>

<p>Tallness matters. The third law of Hoon indentation is that large genes should flow <em>down</em> and not <em>across</em> - like the decrement example above. The right margin is a precious resource not to be wasted. It&#8217;s this law, when properly applied, that makes casual readers wonder if Hoon is a functional language at all. It doesn&#8217;t have a program counter, but it looks like it does - at least when written right.</p>

<p>In list-structured runes, like the <code>:*</code> above, there is no choice but to lose right margin. Fortunately, most runes are tuples, and most have limited &#8220;fanout&#8221; - 1, 2, 3 or at most 4.</p>

<p>Both of our above examples - <code>|=</code> and <code>?:</code> - use &#8220;backstep&#8221; indentation which takes advantage of this tuple structure. For instance, <code>|=</code> has two subgenes, <code>p</code> and <code>q.</code> We put <code>p</code> on the same line as <code>|=</code>, set off by two spaces, losing 4 characters of margin. We put <code>q</code> <em>directly below</em>, losing no margin at all.</p>

<p>It so happens that in almost every actual case of <code>|=</code>, <code>p</code> (the function&#8217;s argument) is relatively light, whereas <code>q</code> (the function&#8217;s body) will be much heavier. Thus, with this pattern of indentation, we lose no margin and our code flows <em>down</em>.</p>

<p>We see this even more in <code>?:</code>, where the conditional test (which is much less likely to be heavy) is first and farthest right, followed by the &#8220;then&#8221; case indented two spaces, followed by the &#8220;else&#8221; case at the same indent as the rune.</p>

<p>Suppose your &#8220;else&#8221; is relatively light, and your &#8220;then&#8221; is heavy? You may prefer the <code>?.</code> rune, Hoon&#8217;s &#8220;unless,&#8221; which puts the else before the then. Or not. And in both <code>?:</code> and <code>?.</code>, the test (which of course can be arbitrarily heavy) is first. It is not necessary for your code to <em>always</em> flow down and not across - just <em>mostly</em>.</p>

<p>The conventional principle which backstep indentation sacrifices, of course, is the idea that absolute indentation depth should correspond to tree depth, loop depth, or some other metric. Hoon is so deeply nested that if tab depth matched tree depth, your margins on anything interesting would be in the next cube to your right. There is perhaps a case for indenting loops, but we don&#8217;t find we miss this cue at all.</p>

<p>The paucity of terminators also eliminates a lot of redundancy in the parser, which can result in relatively exciting syntax errors. Our experience is that this is seldom a big problem, because there are terminated tall forms and the cascade stops with them. It is often a small problem, however.</p>
</div>

<div id="related">
  <h3>Related Posts</h3>
  <ul class="posts">
    
    <li>
      <span>22 Aug 2013 &raquo;</span> <a href="/2013/08/22/Chapter-6-security.html">Chapter 6 &#58; Security</a>
    </li>
    
    <li>
      <span>22 Aug 2013 &raquo;</span> <a href="/2013/08/22/Chapter-3-philosophy.html">Chapter 3 &#58; Hoon - Philosophy</a>
    </li>
    
    <li>
      <span>22 Aug 2013 &raquo;</span> <a href="/2013/08/22/Chapter-2-nock.html">Chapter 2 &#58; Crash course in Nock</a>
    </li>
    
  </ul>
</div>

    
      <div class="footer">
        <div class="disclaimer">
  

  <p>
    Â© Urbit, 2013 &mdash; built with Jekyll using Lagom theme
  </p>
</div>
      </div>
    </div>
  </div>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-xxxx-x']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>